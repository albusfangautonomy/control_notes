<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>System ID</title>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  <h1 id="motivation">Motivation</h1>

<h2 id="model">Model</h2>

<h3 id="use-cases">Use Cases</h3>
<ol>
  <li>Controller Design 2. State Estimation 3. Formal Analysis 5. Simulation</li>
</ol>

<h3 id="model-components">Model Components</h3>
<ol>
  <li>Structure - e.g. second order differential equations, frequency response, process model (with time delay), neural networks</li>
  <li>Parameters - e.g. physical quantities - mass, spring constant</li>
</ol>

<h3 id="how-to-create-a-model">How to create a model</h3>
<p>Scenario 1: You know a lot about the physical system -&gt; <strong>white box</strong> approach: create model directly from <strong>first principles</strong></p>

<p>Scenario 2: You don’t know much about the system -&gt; <strong>black box</strong> approach: <strong>pure system ID</strong></p>

<p>Scenario 3: You combine first principles with fitting -&gt;<strong>grey box</strong> approach: use first principles to derive structure and fit parameters</p>

<hr />

<h1 id="linear-system-identification">Linear System Identification</h1>
<p>Linear, Nonlinear, Online and Recursive system ID. System ID is a data driven method</p>

<p>Choose a model structure that represents the system dynamics and fit a model to the data by picking the parameters</p>

<h2 id="system-id-vs-curve-fit">System ID vs Curve fit</h2>

<h3 id="curve-fit-yft">Curve fit \(y=f(t)\)</h3>

<p>Curve fit only describes the sequence of data but doesn’t describe the underlying mechanisms that created the data. For instance, curve fitting cannot predict the data if system was initialized at different state or even different inputs.</p>

<h3 id="system-id-yfuyt">System ID $$y=f(u,y,t)</h3>

<p>System ID takes into account of correlation between the data points, which depends on previous system state.</p>

<h2 id="typical-system-id-model-candidates">Typical System ID model candidates</h2>
<p><img src="../figures/system_id_models.png" alt="system id model candidates" /></p>

<hr />

<h1 id="system-id-workflow">System ID workflow</h1>

<p><img src="../figures/system_id_workflow.png" alt="system id workflow" /></p>

<h2 id="selecting-a-model-order">Selecting a Model Order</h2>

<h3 id="hankel-singular-value">Hankel Singular Value</h3>
<ol>
  <li>Hankel Singular Values are caluclated by taking the SVD of the Hankel matrix.</li>
  <li>Hankel Singular values can be plotted against model order to show redundant orders to reduce the system.</li>
</ol>

<h2 id="modeling-a-real-system">Modeling a Real System</h2>
<ol>
  <li>Model the system.</li>
  <li>Model the dynamics of disturbance.</li>
</ol>

<h3 id="whiteness-and-correlation-tests">Whiteness and Correlation Tests</h3>
<p><strong>Residual</strong>:</p>
<ol>
  <li>Initialize model at first data point (t=0), predict y at the next time step (t = 1). Caluclate error.</li>
  <li>Initialize model at second data point (t=1), predict y at the next time step (t = 2). Calculate error.</li>
</ol>

<p>…</p>

<ol>
  <li>Initialize model at n-th data point (t = n + 1), predict y at the next time step (t = n + 2). Calculate error.</li>
</ol>

<p>We have a residual curve.</p>

<p><strong>Residual Autocorrelation:</strong> If residual values are correlated with themselves in some way -&gt; there is unmodeled dynamics in disturbance model.</p>

<p><strong>Residual-Input Cross-Correlation:</strong> If residual values are highly cross-correlated with input -&gt; there is unmodeled dynamics in system model.</p>

<hr />

<h1 id="nonlinear-system-id">Nonlinear System ID</h1>

<h2 id="linear-arx-auto-regressive-exogeneous-input">Linear ARX (Auto-Regressive Exogeneous Input)</h2>

<p><img src="../figures/arx.png" alt="Linear ARX" /></p>

<p>An <strong>ARX system</strong> is a type of discrete-time, linear, time-invariant model used in <strong>system identification</strong>, where the output is modeled as an <strong>Auto-Regressive model with eXogenous input</strong>.</p>

<p>The system is described by a linear difference equation:</p>

\[y(t) + a_1 y(t-1) + a_2 y(t-2) + \dots + a_{n_a} y(t-n_a) = b_1 u(t-1) + b_2 u(t-2) + \dots + b_{n_b} u(t-n_b) + e(t)\]

<p>Where:</p>
<ul>
  <li>\(y(t)\) — output at time \(t\)</li>
  <li>\(u(t)\) — input at time \(t\)</li>
  <li>\(e(t)\) — white noise (modeling disturbances)</li>
  <li>\(a_i\) — parameters of the autoregressive part (based on past outputs)</li>
  <li>\(b_i\) — parameters of the exogenous part (based on past inputs)</li>
  <li>\(n_a\) — number of past outputs used</li>
  <li>\(n_b\) — number of past inputs used (often includes a delay \(n_k\))</li>
</ul>

<p>In compact notation:</p>

<p>[
A(q^{-1})y(t) = B(q^{-1})u(t) + e(t)
]</p>

<p>where \(q^{-1}\) is the <strong>backward shift operator</strong> (\(q^{-1} y(t) = y(t-1)\)).</p>

<hr />

<h3 id="key-points">Key Points</h3>
<ul>
  <li><strong>AR</strong> part: models how past outputs affect the current output.</li>
  <li><strong>X</strong> (exogenous) part: models how past inputs affect the current output.</li>
  <li><strong>Linear</strong> in parameters — easy to estimate using least squares.</li>
  <li>Assumes disturbances \(e(t)\) are uncorrelated with the inputs.</li>
</ul>

<hr />

<h2 id="narx-systems">NARX Systems</h2>

<p>A <strong>NARX system</strong> is a <strong>Nonlinear Auto-Regressive model with eXogenous input</strong>.<br />
It extends the ARX model by allowing <strong>nonlinear relationships</strong> between past inputs, past outputs, and the current output.</p>

<p>The general form is:</p>

\[y(t) = F\big( y(t-1), y(t-2), \dots, y(t-n_a), \; u(t-1), u(t-2), \dots, u(t-n_b) \big) + e(t)\]

<p>Where:</p>
<ul>
  <li>\(y(t)\) — output at time \(t\)</li>
  <li>\(u(t)\) — input at time \(t\)</li>
  <li>\(e(t)\) — noise or disturbance</li>
  <li>\(n_a\) — number of past outputs used</li>
  <li>\(n_b\) — number of past inputs used</li>
  <li>\(F(\cdot)\) — a <strong>nonlinear mapping function</strong> (e.g., neural network, polynomial, or other nonlinear model)</li>
</ul>

<p><strong>Note</strong> each of the term may be multiplied by non-linear functions like Fourier-Series.</p>

<hr />

<h3 id="key-points-1">Key Points</h3>
<ul>
  <li>Generalizes ARX by replacing the linear mapping with a <strong>nonlinear function</strong>. ie \((y(t-1))^2 + \sqrt{u(t-1 )}\)</li>
  <li>Captures complex, nonlinear system dynamics more accurately than ARX.</li>
  <li>Commonly used in <strong>machine learning–based system identification</strong>.</li>
  <li>If \(F(\cdot)\) is linear, the NARX model reduces to the ARX model.</li>
</ul>

<h2 id="stability-of-narx">Stability of NARX</h2>
<p>No guarantee of globall stability past captured data. We can approximate the bulk of the system with a linear model which we can analyze the stability of, and capture the remaining residuals with nonlinear terms.</p>

<hr />

<h2 id="online-and-recursive-system-id">Online and Recursive System ID</h2>

<p>The model is developed online over time, using data once it becomes available at each time step. This method is beneficial for <strong>time-varying systems</strong>.</p>

<h3 id="use-cases-of-online-system-id">Use Cases of Online System ID</h3>
<ol>
  <li>
    <p>Adaptive Control</p>

    <ul>
      <li>Time varying systems</li>
    </ul>
  </li>
  <li>
    <p>Fault Detection</p>

    <ul>
      <li>Create fault tests in real time</li>
    </ul>
  </li>
</ol>

<h3 id="finite-history-algorithms">Finite History Algorithms</h3>
<p>Only use part of the most recent past data with a fixed-length window. Online algorithms needs fast execution, so we only use linear models for now.</p>

<p>However, we need to <strong>store these data</strong>.</p>

<h3 id="infinite-history-recursive-algorithms">Infinite History (Recursive) Algorithms</h3>

<p>Every single data point is run recursively but not stored. Faster execution time.</p>

<p>Method 1: Pick a fixed gain K:</p>

<p><img src="../figures/recursive_algorithm_system_id.png" alt="recursive algorithm" /></p>

<p>Method 2: Since fixed gain is not optimal enough:</p>

<p>Use Kalman!!!</p>

</body>
</html>
