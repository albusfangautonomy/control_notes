<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PID Control</title>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  <h1 id="pid-control">PID Control</h1>
<p>This page only covers continuous-time PID control. For more advanced topics on discrete PID, visit Discrete Time Control page for more details.</p>

<p>PID by itself is a linear controller. Gain Scheduling, Anti-windup schemes, derivative filtering, gain scheduling can make it non-linear</p>

<h2 id="which-controller-to-use">Which controller to use?</h2>
<p>\(\begin{array}{c|c|c|c}
Example &amp; System Order &amp; Controller &amp; Reasoning\\
\hline
\text{Controlling mass position using force} &amp; 2 &amp; \text{PD or PID} &amp; \text{Typically needs damping like mass-spring damper, otherwise will oscillate} \\
\text{Controlling V across C using current} &amp; 1 &amp; \text{P or PI} &amp; \text{not much danger of over-shoot or oscillation}  \\
\text{Controlling I across R using voltage} &amp; 0 &amp; \text{P or PI} &amp; \text{not much danger, direct mapping}
\end{array}\)</p>

<p><strong>Note</strong> System order denotes how many ‚Äòintegration‚Äô away is your control input from output. For instance controlling position with force would be a second order system.</p>
<h2 id="pi-vs-pd-vs-pid">PI vs PD vs PID</h2>
<p>The derivative controller is highly sensitive to noise and may throw system into instability.</p>

<h3 id="pi-controller">PI controller</h3>
<p>PI controller reduces both rise time and the steady state errors of the system. Integral term introduces phase lag, which may slow down response time.</p>

<h3 id="pd-controller">PD controller</h3>
<p>A PD controller reduces transients like rise time, overshoot, and oscillations in the output. D controller cannot exist on its own since itself doesn‚Äôt stabilize the system, but amplifies noise.</p>

<hr />

<h2 id="strategies-for-tuning-a-pid-controller">Strategies for Tuning a PID Controller</h2>
<p><img src="../figures/PID_tuning.png" alt="PID tuning chart" /></p>

<h3 id="diagram-walkthrough">Diagram Walkthrough</h3>
<ol>
  <li>Model representation</li>
</ol>

<p><img src="../figures/model_repres.png" alt="What's a model" /></p>
<ol>
  <li>run input sequence
    <ul>
      <li>observe step response for Cohen-Coon</li>
    </ul>
  </li>
  <li>Heuristic Methods:
System model not required, only need to measure certain traits such as process gain, time constant. and dead time.
    <ol>
      <li>Cohen-Coon</li>
      <li>Zeguler-Nichols (needs to be careful on hardware, due to oscillatory behavior)</li>
    </ol>
  </li>
  <li>System Identification.
    <ol>
      <li>Measure step-response of system.</li>
      <li>Tweak your model coefficients so step responses match.</li>
      <li>Model needs to be defined beforehand.</li>
    </ol>
  </li>
  <li>Tuning method with Model
    <ul>
      <li>manual tuning
        <ol>
          <li>pole placement</li>
          <li>Loop Shaping</li>
          <li>Heuristic Methods. (make model oscilatory NOT hardware)</li>
        </ol>
      </li>
      <li>auto tuning</li>
    </ul>
  </li>
</ol>

<h3 id="manual-pid-tuning-strategy">Manual PID Tuning Strategy</h3>

<ol>
  <li><strong>Start with:</strong></li>
</ol>

\[K_P &gt; 0, \quad K_I = 0, \quad K_D = 0\]

<ol>
  <li><strong>Increase \(K_P\)</strong> until:
    <ul>
      <li>The system starts responding to setpoint changes.</li>
      <li>It begins to <strong>oscillate consistently without settling</strong>.</li>
    </ul>

    <p>This means it‚Äôs reached the <strong>edge of stability</strong>.</p>
  </li>
  <li>
    <p><strong>Back off \(K_P\)</strong> by ~10‚Äì20% to get a stable (but responsive) system.</p>
  </li>
  <li><strong>Increase \(K_D\)</strong> to:
    <ul>
      <li>Dampen the oscillations.</li>
      <li>Improve settling time and reduce overshoot.</li>
    </ul>
  </li>
  <li><strong>Increase \(K_I\)</strong> slowly to:
    <ul>
      <li>Eliminate steady-state error (e.g. small drift from setpoint).</li>
      <li>Watch for <strong>overshoot or oscillation</strong> due to <strong>integral windup</strong>.</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="-zieglernichols-method-ultimate-gain-method">üß™ Ziegler‚ÄìNichols Method (Ultimate Gain Method)</h2>

<p>This is a classical tuning rule. It gives you a starting point for 
\(K_P,\ K_I,\ \text{and}\ K_D\)
based on when the system first starts oscillating.</p>

<h3 id="-steps">üîß Steps:</h3>

<ol>
  <li>
    <p><strong>Set:</strong>
\(K_I = 0,\quad K_D = 0\)</p>
  </li>
  <li>
    <p><strong>Increase \(K_P\)</strong> until the system output shows <strong>sustained oscillations</strong> (constant amplitude).</p>

    <ul>
      <li>That value of \(K_P\) is called the <strong>ultimate gain</strong>, denoted:
\(K_u\)</li>
    </ul>
  </li>
  <li>
    <p><strong>Measure the oscillation period</strong> ‚Äî the time between peaks ‚Äî and call it:
\(T_u\)</p>
  </li>
</ol>

<h3 id="-use-these-tables-to-compute-gains">üìê Use these tables to compute gains:</h3>

<table>
  <thead>
    <tr>
      <th>Controller</th>
      <th>\(K_P\)</th>
      <th>\(K_I\)</th>
      <th>\(K_D\)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>P</strong></td>
      <td>\(0.5K_u\)</td>
      <td>‚Äì</td>
      <td>‚Äì</td>
    </tr>
    <tr>
      <td><strong>PI</strong></td>
      <td>\(0.45K_u\)</td>
      <td>\(1.2K_u / T_u\)</td>
      <td>‚Äì</td>
    </tr>
    <tr>
      <td><strong>PID</strong></td>
      <td>\(0.6K_u\)</td>
      <td>\(2K_u / T_u\)</td>
      <td>\(K_u T_u / 8\)</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>Control Type</th>
      <th>\(K_p\)</th>
      <th>\(T_i\)</th>
      <th>\(T_d\)</th>
      <th>\(K_i\)</th>
      <th>\(K_d\)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>P</strong></td>
      <td>\(0.5K_u\)</td>
      <td>‚Äì</td>
      <td>‚Äì</td>
      <td>‚Äì</td>
      <td>‚Äì</td>
    </tr>
    <tr>
      <td><strong>PI</strong></td>
      <td>\(0.45K_u\)</td>
      <td>\(0.8\overline{3}T_u\)</td>
      <td>‚Äì</td>
      <td>\(0.54K_u / T_u\)</td>
      <td>‚Äì</td>
    </tr>
    <tr>
      <td><strong>PD</strong></td>
      <td>\(0.8K_u\)</td>
      <td>‚Äì</td>
      <td>\(0.125T_u\)</td>
      <td>‚Äì</td>
      <td>\(0.10K_u T_u\)</td>
    </tr>
    <tr>
      <td><strong>Classic PID</strong></td>
      <td>\(0.6K_u\)</td>
      <td>\(0.5T_u\)</td>
      <td>\(0.125T_u\)</td>
      <td>\(1.2K_u / T_u\)</td>
      <td>\(0.075K_u T_u\)</td>
    </tr>
    <tr>
      <td><strong>Pessen Integral Rule</strong></td>
      <td>\(0.7K_u\)</td>
      <td>\(0.4T_u\)</td>
      <td>\(0.15T_u\)</td>
      <td>\(1.75K_u / T_u\)</td>
      <td>\(0.105K_u T_u\)</td>
    </tr>
    <tr>
      <td><strong>Some Overshoot</strong></td>
      <td>\(0.3\overline{3}K_u\)</td>
      <td>\(0.50T_u\)</td>
      <td>\(0.3\overline{3}T_u\)</td>
      <td>\(0.6\overline{6}K_u / T_u\)</td>
      <td>\(0.1\overline{1}K_u T_u\)</td>
    </tr>
    <tr>
      <td><strong>No Overshoot</strong></td>
      <td>\(0.20K_u\)</td>
      <td>\(0.50T_u\)</td>
      <td>\(0.3\overline{3}T_u\)</td>
      <td>\(0.40K_u / T_u\)</td>
      <td>\(0.06\overline{6}K_u T_u\)</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="Ô∏è-notes-for-drone-applications">‚ö†Ô∏è Notes for Drone Applications</h3>

<ul>
  <li>Ziegler‚ÄìNichols gives <strong>aggressive</strong> tuning, often with <strong>overshoot</strong>.</li>
  <li>For drones, it‚Äôs safer to:
    <ul>
      <li>Start with <strong>rate control loops</strong> (angular velocity).</li>
      <li>Then move to <strong>attitude control</strong> (roll, pitch, yaw).</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="integral-windup">Integral Windup</h2>
<p>Error builds up even though actuator saturates. takes take for negative error to be reflected in the controller</p>

<p><img src="../figures/windup.png" alt="Integral Windup scenario" /></p>

<h3 id="anti-windup">Anti-Windup</h3>
<p><strong>Most anti-windup schemes prevents integral from accumulating error past a threshold</strong></p>
<ol>
  <li>clamping: two checks (if both true, shut off integration)
    <ul>
      <li>Output is saturating (clamp the output of the PID (<strong>this needs to be conservative</strong>), if the output before and after the clamp are the same, then actuator is beginning to get saturated.)</li>
      <li>Input and output have same sign</li>
    </ul>
  </li>
  <li>block calculation</li>
  <li>observer approach</li>
</ol>

<h2 id="derivative-control">Derivative Control</h2>
<p>Derivative control ‚Äúpredicts the future‚Äù in constrast to integral control - a decrease in error gives a decrease in control input. Noise amplifies Derivative control output.</p>

<h3 id="derivative-control-example">Derivative Control Example</h3>
<p>Altitude Control for Quadcopter:
Desired altitude 50m, as drone shoots up, error term decreases (negative derivative) -&gt; negative value from derivative term, slows motors down, reduce over shoot</p>

<hr />

<h2 id="how-to-derive-a-model">How to derive a model</h2>
<h3 id="first-principles">First principles</h3>
<p>This methods also works if one knows the individual components of the system.</p>
<ol>
  <li>Newtonian Mechanics</li>
  <li>Lagrangian Mechanics</li>
</ol>

<h3 id="system-id">System ID</h3>
<p>If the model is too complicated, system ID can work (black box method). No need to know the details of the system.</p>

<hr />

<h2 id="pid-pole-placement-lqg-and-loop-shaping-robust-control">PID Pole Placement (LQG) and Loop Shaping (Robust Control)</h2>

<h3 id="pid-transfer-function">PID Transfer Function</h3>
<p>\(C(s) = K_p + \frac{K_i}{s} + K_d s\)</p>

<p><img src="../figures/pid_loopshaping_poleplacement.png" alt="PID pole placement and loop shaping png" /></p>

<h3 id="how-does-pid-affect-loop-shaping-bode-plot">How does PID affect Loop Shaping (Bode Plot):</h3>
<p><strong>1. Proportional term (\(K_p\))</strong></p>
<ul>
  <li>Simply scales the magnitude of the open-loop transfer function across all frequencies by \(K_p\) (shifts the Bode magnitude plot up or down).</li>
  <li>No slope change, no phase lead/lag (phase stays the same as the plant‚Äôs at each frequency).</li>
</ul>

<p><strong>2. Integral term (\(\frac{K_i}{s}\))</strong></p>
<ul>
  <li>Adds a pole at \(s=0\) and a zero at \(s=-K_i/K_p\) (if expressed in standard form for PI control).</li>
  <li>In the Bode plot: increases low-frequency gain slope by +20 dB/dec below the zero, giving <strong>better low-frequency tracking</strong> and disturbance rejection.</li>
  <li>Phase: introduces <strong>‚Äì90¬∞ lag</strong> below the zero frequency (eventually reduced to 0¬∞ after the zero).</li>
</ul>

<p><strong>3. Derivative term (\(K_d s\))</strong></p>
<ul>
  <li>Adds a zero at the origin and a pole at infinity (in practice, implemented with a high-frequency roll-off to avoid noise).</li>
  <li>In the Bode plot: increases high-frequency gain slope by +20 dB/dec above the zero‚Äôs frequency, giving <strong>phase lead</strong> and faster response.</li>
  <li>Phase: can give up to +90¬∞ lead around its zero.</li>
</ul>

<p><strong>Putting them together in loop shaping:</strong></p>
<ul>
  <li><strong>Integral</strong> boosts the low-frequency magnitude to push the gain crossover lower and improve steady-state accuracy.</li>
  <li><strong>Derivative</strong> boosts magnitude at mid-frequencies to increase phase margin, which can stabilize a plant with low natural phase margin.</li>
  <li><strong>Proportional</strong> shifts the entire magnitude plot up or down to meet your crossover frequency and gain margin targets.</li>
</ul>

<hr />

<h2 id="pid-effect-on-pole-placement">PID Effect on Pole Placement</h2>

<h3 id="1Ô∏è‚É£-starting-point--closed-loop-poles-come-from-1--ls--0">1Ô∏è‚É£ Starting point ‚Äî closed-loop poles come from \(1 + L(s) = 0\)</h3>

<p>For unity feedback:</p>

\[T(s) = \frac{C(s) G(s)}{1 + C(s) G(s)}\]

<p>The <strong>closed-loop poles</strong> are the roots of:</p>

\[1 + C(s) G(s) = 0\]

<p>Adding a PID means replacing \(C(s)\) with:</p>

\[C(s) = K_p + \frac{K_i}{s} + K_d s\]

<p>That changes the polynomial \(1 + C(s) G(s) = 0\), which changes the pole locations.</p>

<hr />

<h3 id="2Ô∏è‚É£-how-each-term-influences-pole-placement">2Ô∏è‚É£ How each term influences pole placement</h3>

<p><strong>(a) Proportional \(K_p\)</strong></p>
<ul>
  <li>Multiplies the plant‚Äôs transfer function by a constant.</li>
  <li>Effect: Moves the closed-loop poles along the <em>root locus</em> without changing its shape.</li>
  <li>Higher \(K_p\) ‚Üí poles move toward/into the left-half plane faster (increasing speed) but can reduce stability margin.</li>
</ul>

<hr />

<p><strong>(b) Integral \(\frac{K_i}{s}\)</strong></p>
<ul>
  <li>Adds a <strong>pole at the origin</strong> to the <em>open-loop</em> transfer function.</li>
  <li>This changes the root locus shape, not just shifts along it.</li>
  <li>Forces the steady-state error for step inputs to zero by making the closed-loop a <strong>Type 1</strong> system (or higher).</li>
  <li>Because it adds a pole, it can also slow down the system and reduce damping unless compensated.</li>
</ul>

<hr />

<p><strong>(c) Derivative \(K_d s\)</strong></p>
<ul>
  <li>Adds a <strong>zero</strong> to the open-loop transfer function.</li>
  <li>Zeros bend the root locus toward themselves, which can move dominant poles to locations with higher damping ratio.</li>
  <li>Used to improve transient response (overshoot, settling time) by pulling poles into a ‚Äúnicer‚Äù part of the complex plane.</li>
</ul>

<hr />

<h3 id="3Ô∏è‚É£-big-picture-pid-in-pole-placement-terms">3Ô∏è‚É£ Big picture: PID in pole placement terms</h3>

<ul>
  <li><strong>P</strong>: Changes <em>gain</em> ‚Üí moves poles along an existing root-locus path.</li>
  <li><strong>I</strong>: Adds a pole at origin ‚Üí changes the <em>shape</em> of the root locus, introduces the integrator effect.</li>
  <li><strong>D</strong>: Adds a zero ‚Üí bends the root locus toward more desirable damping.</li>
</ul>

<p>The net effect is that PID changes <strong>both</strong>:</p>
<ol>
  <li>The <em>geometry</em> of the root locus (via added poles/zeros)</li>
  <li>The <em>position</em> along that locus (via gain tuning)</li>
</ol>

<hr />

<h2 id="gain-scheduling---control-systtems-in-practice">Gain Scheduling - Control Systtems in Practice</h2>

<h3 id="movivation">Movivation</h3>
<p>Linear controllers may only work well under certain operating conditions but not all.</p>

<p>Linear Parameter Varying systems:
A fixed lienar transfer function but different parameters under different operating conditions.</p>

<p><strong>How to deal with LPV systems?</strong></p>
<ol>
  <li>Build nonlinear controler.</li>
  <li>Build linear robust controller. Drop in performance and may not even be possible.</li>
  <li>Limit operations.</li>
  <li>Gain scheduling.</li>
</ol>

<h3 id="visualization">Visualization</h3>
<p><img src="../figures/gain_scheduling.png" alt="visualizing PID gain scheduling" /></p>

<h3 id="implementation">Implementation</h3>
<p>Steps</p>
<ol>
  <li>Linearize plant at each design operating condition. (linear controller for linear plant)
    <ul>
      <li>find a critical point in each of the regions that represents the whole area well</li>
      <li>Linearize plant at the point</li>
    </ul>
  </li>
  <li>Tune gains at each design point
    <ul>
      <li>Performance (or even stability in some cases) is only guaranteed at the design points</li>
      <li>Either use a single gain for the entire area or <strong>Interpolate</strong> gains between two points</li>
      <li>Make controller more robust or add more design points</li>
    </ul>
  </li>
  <li>Choose the gain scheduling architecture
    <ul>
      <li>A switch system. However, it may produce some unintended transients at the switch condition</li>
      <li>See next section for more details</li>
    </ul>
  </li>
  <li>Assess the control performance
    <ul>
      <li>Often simulated</li>
      <li>All critical transitions and corner cases should be covered</li>
    </ul>
  </li>
</ol>

<h3 id="preventing-drastic-changes">Preventing drastic changes</h3>
<p><strong>Scenario</strong> At the boundary points of the gain areas, errors don‚Äôt change much, but a discrete switch causes controller gain to change -&gt; causing erratic behavior.</p>

<p><strong>Methods</strong></p>
<ol>
  <li>
    <p>Transient-free Switch
<img src="../figures/transient_free_switch.png" alt="Transient Free Switch" /></p>
  </li>
  <li>
    <p>Gain curve (2D) and Gain Surface (3D)
<img src="../figures/gain_surface.png" alt="Gain Curve and Gain Surface" /></p>
  </li>
</ol>

<hr />

<h2 id="important-advanced-pid-concepts-for-further-study">Important Advanced PID concepts for Further Study</h2>

<h3 id="cascade-loops">Cascade Loops</h3>

<p><img src="../figures/cascade_pid.png" alt="Cascade PID Diagram" /></p>

<p>Why multiple loops?</p>
<ol>
  <li><strong>Inner loops can be tuned to respond quickly to local disturbances, the outer loop can be tuned more conservatively to reject sensor noise and increase stability</strong></li>
  <li>Cascade approach makes it easier to isolate the problem</li>
  <li>Multiple groups can work separate parts.
    <ul>
      <li>The motor you buy has a built-in controller</li>
    </ul>
  </li>
</ol>

<hr />

<p>How to Tune Cascade loops</p>
<ol>
  <li>Case 1: Inner loop speed¬†¬ª outer loop speed
    <ul>
      <li>can be tuned separately. Assume the other loops not present and tune like normal</li>
    </ul>
  </li>
  <li>Case 2: Inner loop speed \(\approx\) Outerloop speed
    <ul>
      <li>Tune inner loop with a guess</li>
      <li>Tune outer loop</li>
      <li>Iterate</li>
    </ul>
  </li>
</ol>

<h3 id="discrete-pid">Discrete PID</h3>
<p>There are three major characteristics of a digital system:  1. <strong>Sample Time</strong> 2. <strong>Quatization</strong> 3. <strong>Transport Delay</strong></p>

<p><strong>Please check out discrete time control page for more details on discrete PID controller</strong></p>


</body>
</html>
