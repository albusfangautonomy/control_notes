{"0": {
    "doc": "About",
    "title": "About",
    "content": "This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at jekyllrb.com . You can find the source code for Minima at GitHub: jekyll / minima . You can find the source code for Jekyll at GitHub: jekyll / jekyll . ",
    "url": "/about/",
    
    "relUrl": "/about/"
  },"1": {
    "doc": "Drone Control",
    "title": "Full Dynamic Model of a Truck (Kodiak Interview Prep)",
    "content": "Understanding the full dynamic model of a truck is critical for interviews with autonomous trucking companies like Kodiak. Trucks have unique dynamics due to their size, mass distribution, and articulated trailer structure. ",
    "url": "/domain_specific_control/car.html#full-dynamic-model-of-a-truck-kodiak-interview-prep",
    
    "relUrl": "/domain_specific_control/car.html#full-dynamic-model-of-a-truck-kodiak-interview-prep"
  },"2": {
    "doc": "Drone Control",
    "title": "1. Basic Models (Used in Control &amp; Estimation)",
    "content": "A. Kinematic Bicycle Model . | Simplified model assuming no slip, pure rolling. | State: \\(x, y, \\theta, v\\) | Control: \\(a, \\delta\\) (acceleration and steering angle) | . \\[\\dot{x} = v \\cos\\theta, \\quad \\dot{y} = v \\sin\\theta, \\quad \\dot{\\theta} = \\frac{v}{L} \\tan\\delta\\] Use case: low-speed control and path planning . B. Dynamic Single-Track Model (No Trailer) . | Captures lateral slip, yaw dynamics, and tire forces. | States: \\(x, y, \\theta, v_x, v_y, r\\) | Inputs: \\(F_x\\), \\(\\delta\\) | . Equations of motion: . | Longitudinal: \\(m(\\dot{v}_x - v_y r) = F_{x,f} \\cos\\delta - F_{y,f} \\sin\\delta + F_{x,r}\\) | Lateral: \\(m(\\dot{v}_y + v_x r) = F_{x,f} \\sin\\delta + F_{y,f} \\cos\\delta + F_{y,r}\\) | Yaw: \\(I_z \\dot{r} = a F_{y,f} \\cos\\delta + a F_{x,f} \\sin\\delta - b F_{y,r}\\) | . Where: . | \\(a\\), \\(b\\): distances from CG to front/rear axle | \\(F_{y,f}\\), \\(F_{y,r}\\): lateral tire forces from slip angles | \\(F_{x,f}\\), \\(F_{x,r}\\): longitudinal tire forces | . ",
    "url": "/domain_specific_control/car.html#1-basic-models-used-in-control--estimation",
    
    "relUrl": "/domain_specific_control/car.html#1-basic-models-used-in-control--estimation"
  },"3": {
    "doc": "Drone Control",
    "title": "2. Truck-Specific Models",
    "content": "C. Articulated Truck Model (Tractor + Trailer) . Essential for Kodiak! Includes yaw dynamics and articulation between tractor and trailer. Typical state vector: \\(\\mathbf{x} = [x, y, \\psi_t, \\psi_{tr}, v_x, v_y, r_t, r_{tr}]\\) . | \\(\\psi_t\\): yaw angle of tractor | \\(\\psi_{tr}\\): yaw angle of trailer | \\(r_t\\), \\(r_{tr}\\): yaw rates | Articulation angle: \\(\\phi = \\psi_{tr} - \\psi_t\\) | Articulation rate: \\(\\dot{\\phi} = r_{tr} - r_t\\) | . Yaw Dynamics (high-level): . | Tractor: \\(I_{z,t} \\dot{r}_t = \\text{sum of moments on tractor}\\) | Trailer: \\(I_{z,tr} \\dot{r}_{tr} = \\text{sum of moments on trailer}\\) | . Used for high-speed motion, stability control, and trailer swing suppression. ",
    "url": "/domain_specific_control/car.html#2-truck-specific-models",
    
    "relUrl": "/domain_specific_control/car.html#2-truck-specific-models"
  },"4": {
    "doc": "Drone Control",
    "title": "3. Higher-Fidelity Models (for Simulation &amp; MPC)",
    "content": ". | Pacejka ‚ÄúMagic Formula‚Äù for nonlinear tire force modeling | Suspension &amp; compliance modeling | ABS/EBS braking system dynamics | Multi-body dynamics of each axle and articulation constraint | . ",
    "url": "/domain_specific_control/car.html#3-higher-fidelity-models-for-simulation--mpc",
    
    "relUrl": "/domain_specific_control/car.html#3-higher-fidelity-models-for-simulation--mpc"
  },"5": {
    "doc": "Drone Control",
    "title": "Summary Table",
    "content": "| Model | Captures | Use Cases | . | Kinematic Bicycle | No dynamics or slip | Path planning, low-speed control | . | Dynamic Single Track | Lateral slip, yaw | Medium-speed control, stability analysis | . | Articulated Truck Model | Tractor-trailer coupling | High-speed maneuvering, safety, control | . | Full Multi-Body Model | All dynamics | Simulation, MPC, offline validation | . ",
    "url": "/domain_specific_control/car.html#summary-table",
    
    "relUrl": "/domain_specific_control/car.html#summary-table"
  },"6": {
    "doc": "Drone Control",
    "title": "Drone Control",
    "content": " ",
    "url": "/domain_specific_control/car.html",
    
    "relUrl": "/domain_specific_control/car.html"
  },"7": {
    "doc": "Compensators",
    "title": "Lead, Lag, and Lead-Lag Compensators",
    "content": " ",
    "url": "/notes/compensators.html#lead-lag-and-lead-lag-compensators",
    
    "relUrl": "/notes/compensators.html#lead-lag-and-lead-lag-compensators"
  },"8": {
    "doc": "Compensators",
    "title": "Phase Margin",
    "content": "Definition . Phase margin is a measure of stability for a feedback control system. It represents the amount of phase shift, expressed in degrees, that can be added to the open-loop transfer function before the system reaches the point of instability, specifically where the Bode plot crosses the -180¬∞ line at the gain crossover frequency. Phase Margin Calculation: . \\[\\text{Phase Margin} = 180^\\circ + \\angle G(j\\omega_{gc})H(j\\omega_{gc})\\] . | \\(\\omega_{gc}\\) is the gain crossover frequency ‚Äî the frequency at which the magnitude of the open-loop transfer function \\(|G(j\\omega)H(j\\omega)| = 1\\) (i.e., 0 dB). | \\(\\angle G(j\\omega)H(j\\omega)\\) is the phase of the open-loop transfer function at that frequency. | . ",
    "url": "/notes/compensators.html#phase-margin",
    
    "relUrl": "/notes/compensators.html#phase-margin"
  },"9": {
    "doc": "Compensators",
    "title": "Phase Lead and Lag",
    "content": "A zero (s) adds phase while pole (1/s) subtracts phase. Phase lead compensators add positive phase to the output, so the output leads the input. Phase lag compensators add negative phase to the output, so the output lags behind the input. Phase Lead . Example: Differentiator . input: sin(t) output: cos(t) . Cosine is leading sine by 90 degrees -&gt; phase lead . A differentiator circuit introduces a positive phase shift of 90 degrees . Phase Lag . Example: Integrator . ",
    "url": "/notes/compensators.html#phase-lead-and-lag",
    
    "relUrl": "/notes/compensators.html#phase-lead-and-lag"
  },"10": {
    "doc": "Compensators",
    "title": "Lead Lag Compensator Formulae",
    "content": ". ",
    "url": "/notes/compensators.html#lead-lag-compensator-formulae",
    
    "relUrl": "/notes/compensators.html#lead-lag-compensator-formulae"
  },"11": {
    "doc": "Compensators",
    "title": "Lead Compensator",
    "content": "Formula . \\(\\frac{\\omega_p}{\\omega_z} * \\frac{s+\\omega_z}{s+\\omega_p}\\) or \\(\\frac{s+\\omega_z}{\\omega_z} * \\frac{\\omega_p}{s+\\omega_p}\\) . | 1 pole and 1 zero | \\(\\omega_z &lt; \\omega_p\\) | . Bode Plot . | Lead compensators increase gain at high frequencies but not as much as a real zero = less noise amplification | Lead compensator adds phase (phase lead) between the corner frequencies \\(\\omega_z \\text{ and } \\omega_p\\) and nowhere else. By adjusting the corner frequencies, you can move the phase lead around | . Intuition . | Lead compensator (phase lead) drags the asymptotes and the closed loop poles to the left, which adds stability. | Lead compensated system is more stable and has a faster rise time. | Lead compensator shapes the root locus | . | Lag compensator is typically not used for dragging asymptotes closer to imaginary axis, but rather for reducing steady-state errors. | We want to reduce steady-state errors without changing the pole locations | Lag compensator doesn‚Äôt shape the root locus plot | . | . Notes on Lead Compensators . | A lead compensator doesn‚Äôt guarantee stability | Lead compensator can be tried if PID doesn‚Äôt work | Faster response means responding to noise | . ",
    "url": "/notes/compensators.html#lead-compensator",
    
    "relUrl": "/notes/compensators.html#lead-compensator"
  },"12": {
    "doc": "Compensators",
    "title": "Lag Compensator",
    "content": "Formula . \\(\\frac{\\omega_p}{\\omega_z} * \\frac{s+\\omega_z}{s+\\omega_p}\\) or \\(\\frac{s+\\omega_z}{\\omega_z} * \\frac{\\omega_p}{s+\\omega_p}\\) . | 1 pole and 1 zero | \\(\\omega_z &lt; \\omega_p\\) | . Lag Compensator Bode Plot . How does Lag compensator reduce SSE . Lag compensator can only reduce SSE but not eliminate it. To eliminate, change system Type. Lag Compensator Step Response . \\(E_{ssc}\\) is the desired steady-state error given by spec. \\(\\frac{z}{p}\\) is the zero-to-pole ratio and can be calculated. However, the exact location needs further analysis . Where should you place the zero and pole given zero-to-pole ratio . A locus exists where the angles add to 180 degrees. We do NOT want to move the dominant pole much with lag compensators. We want to place them in such a way that the angles of the compensator zero and pole cancel each other out. | If we place the zero and pole to the left of the dominant poles, the difference between the two angles will be significant, which will drag the dominant poles to the right (undesirable behavior). | If we place the zero and pole close to the imaginary axis but keep zero-to-pole ratio \\(\\frac{z}{p}\\) . | . Rule of Thumb . | Maintain \\(\\frac{z}{p}\\) needed for steady-state error | Place lag compensator as close to imaginary axis as possible to reduce moving the roots. | Not too close since it‚Äôs hard to implement | Zero should be \\(Z_{lag} = \\frac{\\text{real(Dominant Pole)}}{50}\\) | . | . ",
    "url": "/notes/compensators.html#lag-compensator",
    
    "relUrl": "/notes/compensators.html#lag-compensator"
  },"13": {
    "doc": "Compensators",
    "title": "Lead Lag Compensator",
    "content": ". ",
    "url": "/notes/compensators.html#lead-lag-compensator",
    
    "relUrl": "/notes/compensators.html#lead-lag-compensator"
  },"14": {
    "doc": "Compensators",
    "title": "Designing a Lead-Lag compensator with Root Locus",
    "content": "Designing Lead first . | Decide on desired poles given criteria (making the system appear second order) (e.g. rise time, damping ratio) . | Place lead zero in a position that minimizes effect on dominant closed-loop poles . | Keep zero left of closed-loop poles OR . | Cancel an existing system pole . | . | Find where lead pole needs to be placed to get desired poles on root locus . | For a desired pole (either one of the complex conjugate, answers are the same), ignoring its complex conjugate pole in the following formula: \\(\\Sigma \\theta_z - \\Sigma \\theta_p = -180^\\circ\\) . | Use trigonometry to figure out \\(l\\) and \\(\\theta\\), distance between each open-loop pole and zero and angle between the line that connects a desired pole to each of the open-loop poles or zeros and the positive x-axis, respectively. | . | Find what gain (K) this desired pole corresponds to: . | \\(K = \\frac{\\Pi L_{poles}}{\\Pi L_{zeroes}}\\), where \\(\\Pi\\) is the multiplication function OR . | \\[K = \\frac{1}{|GH|}\\] | . | . Designing Lag . | Calculate SSE with lead controller using Final Value Theorem and determining the type of the system . | Lag compensator will reduce SSE | . | Find ratio \\(\\frac{z}{p}\\) from SSE criteria where \\(e_{lead\\_lag}\\) is the desired SSE given by spec. | \\[\\frac{e_{lead}}{e_{lead\\_lag}} = \\frac{z}{p}\\] | . | Pick \\(P_{lag}\\) or \\(Z_{lag}\\) so it is close to the origin, typically \\(Z_{lag}\\). | Calculate \\(P_{lag}\\) given the ratio \\(\\frac{z}{p}\\). Should end up with \\(Z_{lag}\\) and \\(P_{lag}\\) very close to each other to have pole-zero cancellation and an almost unchanged root locus plot | . Dominant poles and System Requirement Constraints . Many system requirements pertaining to transient response (rise time, overshoot, settling time) are only well-defined for a second-order system. It is therefore important to determine where the dominant poles should reside to resemble a second-order system. Pole Placement . | If the dominant poles are to the left of the uncompensated root-locus, then lead must be added to the system. | If the dominant poles are to the right of the uncompensated root-locus, then lag must be added to the system. | . ",
    "url": "/notes/compensators.html#designing-a-lead-lag-compensator-with-root-locus",
    
    "relUrl": "/notes/compensators.html#designing-a-lead-lag-compensator-with-root-locus"
  },"15": {
    "doc": "Compensators",
    "title": "Compensators",
    "content": " ",
    "url": "/notes/compensators.html",
    
    "relUrl": "/notes/compensators.html"
  },"16": {
    "doc": "Controllability",
    "title": "Equivalence",
    "content": ". | System is controllable | Arbitrary Eigenvalue (Pole) placement is allowed . | \\[u = -Kx \\Rightarrow \\dot{x} = (A-BK)x\\] | . | Reachability (full in \\(\\mathbb{R}^n\\)) . | Theoretically one can drive from Massachusetts to California in a second | This can be proven by Cayley-Hamilton theorem | . | . ",
    "url": "/notes/controllability.html#equivalence",
    
    "relUrl": "/notes/controllability.html#equivalence"
  },"17": {
    "doc": "Controllability",
    "title": "Cayley-Hamilton Theorem",
    "content": "Almost every square matrix satisfies its own characteristic equation . The characteristic polynomial of matrix \\(A\\) is defined as: \\(p_A(\\lambda) = \\det(\\lambda I_n - A)\\) Since this is a degree-\\(n\\) monic polynomial, it can be written as: \\(p_A(\\lambda) = \\lambda^n + c_{n-1} \\lambda^{n-1} + \\cdots + c_1 \\lambda + c_0\\) By replacing the scalar variable \\(\\lambda\\) with the matrix \\(A\\), we define the matrix polynomial: \\(p_A(A) = A^n + c_{n-1} A^{n-1} + \\cdots + c_1 A + c_0 I_n\\) . ",
    "url": "/notes/controllability.html#cayley-hamilton-theorem",
    
    "relUrl": "/notes/controllability.html#cayley-hamilton-theorem"
  },"18": {
    "doc": "Controllability",
    "title": "Controllability",
    "content": " ",
    "url": "/notes/controllability.html",
    
    "relUrl": "/notes/controllability.html"
  },"19": {
    "doc": "Controllability",
    "title": "Stabilizability",
    "content": "Controllability for a large dimension space may be too extreme and sometimes unrealistic. For this purpose, stabilizability is defined as: . Stabilizability A system is stabilizable if and only if all unstable (or lightly damped) eigenvectors of A are in controllable subspace. (Anything unstable can be damped) . Actuator B should be designed so that the unstable dynamic directions correspond to the big singular vector of the controllability matrix. Examples of Stabilizability . | Inverted Pendulum on a cart . | Unstable Mode: the pendulum tipping over (angle grows exponentially). | Why Stabilizable: . | The cart can move left or right, providing a restoring torque - can be damped. | . | . | Rocket During Takeoff . | Unstable Mode: pitch/roll drift - if thrust isn‚Äôt perfectly aligned, rocket tips and diverges. | Why Stabilizable: . | Thrust vector control changes the direction of the force relative to the center of mass. This gives direct control authority over the unstable angular dynamics. | . | . | Drone in hover (quadcopter) . | Unstable Mode: attitude - if it tilts slightly, gravity pulls it further, the drone accelerates away. | Why stabilizable: . | Each rotor produces torque about pitch, roll, and yaw. | These torques directly act on the unstable angular states. | Feedback (from IMU + controllers) lets you push those unstable poles into the stable LHP | . | . | . ",
    "url": "/notes/controllability.html#stabilizability",
    
    "relUrl": "/notes/controllability.html#stabilizability"
  },"20": {
    "doc": "Controllability",
    "title": "Controllability of Linear system",
    "content": "\\(\\dot{x}=Ax+Bu\\) \\(y=Cx\\) This system is controllable if and only if the controllability matrix \\(C=[B\\ AB\\ A^2B\\ ...\\ A^{n-1}B]\\) is of full column rank . Note: This is a binary check. To see how controllable this system is, investigate the SVD of C. ",
    "url": "/notes/controllability.html#controllability-of-linear-system",
    
    "relUrl": "/notes/controllability.html#controllability-of-linear-system"
  },"21": {
    "doc": "Controllability",
    "title": "Degrees of Controllability",
    "content": "The Singular Value Decomposition (SVD) of the controllability matrix provides deep insight into the degree and direction of controllability of a linear system: . | Controllability Rank If \\(C\\) has full rank (i.e. rank = number of states \\(n\\)), the system is completely controllable. The number of nonzero singular values = the rank of \\(C\\). | Strength of Controllability (Conditioning) The magnitude of the singular values tells you how ‚Äústrongly‚Äù controllable the system is in different directions: . Large singular values ‚Üí easy to move the system in that direction. Tiny singular values ‚Üí very difficult to control (require large input energy). Zero singular values ‚Üí system not controllable in that direction. | Controllable Directions The right singular vectors \\(V\\) from \\(C = U \\Sigma V^\\top\\) span the input space. The left singular vectors \\(U\\) represent orthogonal directions in the state space. Directions associated with large singular values in \\(U\\) are the most controllable. | . ",
    "url": "/notes/controllability.html#degrees-of-controllability",
    
    "relUrl": "/notes/controllability.html#degrees-of-controllability"
  },"22": {
    "doc": "Controllability",
    "title": "Controllability Gramian",
    "content": "The eigenvectors of the Gramian (\\(W_t\\)) that correspond to the biggest eigenvalues are the most controllable directions in state space. This is the same as the first column vector of the U matrix of the SVD of controllability matrix . \\(W_{t} \\approx CC^T\\) The determinant of the Gramian indicates the volume of the ellipsoid and the signal-to-noise ratio. The controllability Gramian is a matrix that quantifies how easily a system‚Äôs state can be driven by the input. It measures the energy required to move the system from the origin to a particular state. üîß System Setup . For a linear time-invariant (LTI) system: . \\[\\dot{x}(t) = A x(t) + B u(t)\\] The finite-horizon controllability Gramian over the time interval \\([0, T]\\) is: . \\[W_c(T) = \\int_0^T e^{A\\tau} B B^\\top e^{A^\\top \\tau} \\, d\\tau\\] If \\(A\\) is stable and \\(T \\to \\infty\\), the infinite-horizon controllability Gramian is: . \\[W_c = \\int_0^\\infty e^{A\\tau} B B^\\top e^{A^\\top \\tau} \\, d\\tau\\] . üìå What the Gramian Tells You . ‚úÖ 1. Controllability Test . | The system is controllable if and only if \\(W_c\\) is positive definite. | If \\(W_c\\) is singular (has zero eigenvalues), some states cannot be reached from the origin. | . ‚ö° 2. Energy to Reach a State . The minimum energy to reach a state \\(x_f\\) from the origin is: . \\[E = x_f^\\top W_c^{-1} x_f\\] States in directions with small eigenvalues of \\(W_c\\) require more energy to reach. üìê 3. Geometric Interpretation . The ellipsoid: . \\[\\left\\{ x \\in \\mathbb{R}^n : x^\\top W_c^{-1} x \\leq 1 \\right\\}\\] describes the set of states reachable with unit energy. This is known as the reachable ellipsoid. üéØ 4. Mode-wise Controllability . If \\(W_c\\) has a mix of large and small eigenvalues, then some state directions are harder to control than others. Notes . | The controllability Gramian is only defined for linear systems and often assumes zero initial state. | The controllability Gramian is symmetric and positive semi-definite. | . ",
    "url": "/notes/controllability.html#controllability-gramian",
    
    "relUrl": "/notes/controllability.html#controllability-gramian"
  },"23": {
    "doc": "Controllability",
    "title": "PBH Test",
    "content": "(A,B) is controllable if and only if \\(\\text{rank}[(A-\\lambda I)\\ B] = n \\quad \\forall \\lambda \\in \\mathbb{C}\\) . | \\(\\text{rank}(A-\\lambda I)=n\\) except for eigenvalues \\(\\lambda\\) | B needs to have some component in each eigenvector direction | (Advanced) A random vector B would make (A,B) controllable with high probability | . ",
    "url": "/notes/controllability.html#pbh-test",
    
    "relUrl": "/notes/controllability.html#pbh-test"
  },"24": {
    "doc": "Controllability",
    "title": "Reachability",
    "content": "In control theory, reachability describes whether it is possible to move a system from an initial state to a desired final state using admissible control inputs over a finite time interval. For a continuous-time linear time-invariant (LTI) system described by: . \\[\\dot{x}(t) = A x(t) + B u(t)\\] where: . | \\(x(t) \\in \\mathbb{R}^n\\) is the state vector, | \\(u(t) \\in \\mathbb{R}^m\\) is the control input, | \\(A \\in \\mathbb{R}^{n \\times n}\\) is the system matrix, | \\(B \\in \\mathbb{R}^{n \\times m}\\) is the input matrix, | . the system is reachable if, for any initial state \\(x(0)\\) and any final state \\(x_f\\), there exists an input \\(u(t)\\) that drives the system from \\(x(0)\\) to \\(x_f\\) in finite time. Reachability Matrix . The reachability of the system can be tested using the reachability matrix: . \\[\\mathcal{R} = \\begin{bmatrix} B &amp; AB &amp; A^2B &amp; \\cdots &amp; A^{n-1}B \\end{bmatrix}\\] If \\(\\mathcal{R}\\) has full rank (i.e., \\(\\text{rank}(\\mathcal{R}) = n\\)), then the system is reachable. üéØ Reachability Set . The reachability set (or reachable set) at time \\(t_f\\) is the set of all states that the system can reach from an initial state \\(x(0)\\) under some admissible input \\(u(t)\\) over the time interval \\([0, t_f]\\). Formally, for a continuous-time LTI system: . \\[\\dot{x}(t) = A x(t) + B u(t), \\quad x(0) = 0\\] the reachability set at time \\(t_f\\) is defined as: . \\[\\mathcal{R}(t_f) = \\left\\{ x(t_f) \\in \\mathbb{R}^n \\;\\middle|\\; x(t_f) = \\int_0^{t_f} e^{A(t_f - \\tau)} B u(\\tau) \\, d\\tau,\\; u(\\cdot) \\in \\mathcal{L}^2[0, t_f] \\right\\}\\] This set contains all possible states the system can reach at time \\(t_f\\) from the origin with square-integrable inputs \\(u(t)\\). If \\(\\mathcal{R}(t_f)\\) spans \\(\\mathbb{R}^n\\) for some finite \\(t_f\\), the system is reachable. For discrete-time systems: . \\[x[k+1] = A x[k] + B u[k], \\quad x[0] = 0\\] the reachability set after \\(N\\) steps is: . \\[\\mathcal{R}_d(N) = \\left\\{ x[N] = \\sum_{i=0}^{N-1} A^i B u[N-1-i] \\;\\middle|\\; u[i] \\in \\mathbb{R}^m \\right\\}\\] The union of all such sets over all \\(t_f\\) (or \\(N\\) in discrete time) is the total reachable set from the origin. ",
    "url": "/notes/controllability.html#reachability",
    
    "relUrl": "/notes/controllability.html#reachability"
  },"25": {
    "doc": "Discrete-Time Control",
    "title": "Discrete-Time Control",
    "content": " ",
    "url": "/notes/discrete-control.html",
    
    "relUrl": "/notes/discrete-control.html"
  },"26": {
    "doc": "Discrete-Time Control",
    "title": "Continuous vs Discrete Time domain (Analog vs Digital)",
    "content": ". | Quantization Error would be introduced and can be minimized. There is a trade-off between bits, measurement range and quantization error. | Discrete time (digital) systems introduce delay, which introduces lag and reduces bandwidth of controller. | . ",
    "url": "/notes/discrete-control.html#continuous-vs-discrete-time-domain-analog-vs-digital",
    
    "relUrl": "/notes/discrete-control.html#continuous-vs-discrete-time-domain-analog-vs-digital"
  },"27": {
    "doc": "Discrete-Time Control",
    "title": "Discretizing the system",
    "content": "Two ways to approach this problem. ",
    "url": "/notes/discrete-control.html#discretizing-the-system",
    
    "relUrl": "/notes/discrete-control.html#discretizing-the-system"
  },"28": {
    "doc": "Discrete-Time Control",
    "title": "Discrete Time Fourier Transform",
    "content": "The Discrete-Time Fourier Transform (DTFT) of a discrete-time signal \\(x[n]\\) is defined as: . \\[X(e^{j\\omega}) = \\sum_{n=-\\infty}^{\\infty} x[n] e^{-j\\omega n}\\] This calculates how correlated the time domain signal is with all frequencies. DTFT works on finite time signals unlike Z transform. ",
    "url": "/notes/discrete-control.html#discrete-time-fourier-transform",
    
    "relUrl": "/notes/discrete-control.html#discrete-time-fourier-transform"
  },"29": {
    "doc": "Discrete-Time Control",
    "title": "Z domain and Z transform",
    "content": "Z transform can be considered as the discrete-time counterpart of the Laplace Transform. The Z-transform of a discrete-time signal \\(x[n]\\) is defined as: . \\[X(z) = \\sum_{n=-\\infty}^{\\infty} x[n] z^{-n}\\] where \\(z = r*e^{i \\omega}\\) . An n time delay in z domain would be \\(\\frac{1}{z^n}\\). Z transform vs DTFT . Intuition . | Z transform calculates the correlation between the time domain signal and combinations of both sinusoids and exponentials, which solves most linear shift invariant systems. | Unlike DTFT, Z transform has convergence problems . | For instance, for infinite discrete time signal, when there‚Äôs no frequency profile, when the probing signal grows at the same rate at which time signal decays, the sum goes to infinity. (See figure below) Even though all subsequent smaller r would also make the sum \\(\\infty\\), the first instance when the sum does not converge is when a perfect correlation has been found. A pole exists here. | For a finite discrete time signal, the sum for z transform always converges. We therefore cannot investigate finite time signals with Z transform without an assumption (signal = 0 for rest of time). In such a case DTFT is useful. | . | . ",
    "url": "/notes/discrete-control.html#z-domain-and-z-transform",
    
    "relUrl": "/notes/discrete-control.html#z-domain-and-z-transform"
  },"30": {
    "doc": "Discrete-Time Control",
    "title": "",
    "content": " ",
    "url": "/notes/discrete-control.html",
    
    "relUrl": "/notes/discrete-control.html"
  },"31": {
    "doc": "Discrete-Time Control",
    "title": "Z plane and Z domain",
    "content": ". Z domain is the discrete counterpart of the Laplace S domain. However, Z-domain is not a straight discretization of the S-domain, rather Z domain maps S-domain into a unit circle in polar coordinates as explained below. Z Plane and S Plane . Z plane is in polar coordinates, while S plane is in Cartesian coordinates. Since \\(z = r*e^{i \\omega} = e^{sT} = e^{\\sigma + i \\omega T}\\), the real part \\(e^{\\sigma T}\\) scales the circle. The black line enclosing the unit circle and separates the inside and outside of the circle in the Z plane corresponds to the Imaginary axis in the S plane. \\(e^{i \\omega T}\\) traces a circle. For a continuous domain, there are infinite frequencies so S plane goes from \\(-\\infty\\) to \\(\\infty\\). However, in discrete systems, frequency only goes from \\([-f_{nyquist}, f_{nyquist}]\\) on the imaginary axis (real axis on S plane still goes to infinity). \\[f_{nyquist} = f_{sampling} / 2\\] Since frequency is represented by the angle between a line and positive x-axis on the Z plane, Nyquist frequency represents the . Defining \\(z = e^{sT}\\) makes implementing physical hardware easy, since inverse Z transform to difference equation is trivial. This is due to the fact that \\(z^{-1}\\) corresponds to a single time step delay in time domain for the difference equation. Note the coefficients of the difference equation correspond to those in the transfer function. This makes the inverse Z transform trivial. ",
    "url": "/notes/discrete-control.html#z-plane-and-z-domain",
    
    "relUrl": "/notes/discrete-control.html#z-plane-and-z-domain"
  },"32": {
    "doc": "Discrete-Time Control",
    "title": "Discretization Method",
    "content": "There are 5 different methods: . | Zero Order Hold | First Order Hold | Impulse | Tustin | Matched | . ZOH (step invariant), FOH (ramp invariant), and Impulse invariant all produce specific time-domain responses. The method you choose depends on what you are trying to accomplish. (Minimizing the loss of important info.) . | We may want the frequency response of the discrete system to be the same as the continuous system. (Notch filter) | We may want the step response to be the same. | . Note If the time constant of your system is slow compared to the sample time, all methods are the same. When time constant is bigger, these 5 methods produce different results by prioritizing different aspects. Impulse Invariant Method . This method ensures the discrete impulse is the same as the continuous impulse response. Note that Matlab defines impulse differently than Kronecker delta and is scaled by \\(T_s\\). Impulse invariant method uses an impulse train as inputs, which is not realistic. ZOH is more realistic. Impulse invariant method would yield erroneous step response. Zero Order Hold (Step Invariant Method) . ZOH holds the value at the previous time step until the next time step is reached. However, ZOH method would yield inaccurate impulse response. Walkthrough: . | Start with discrete time domain signal \\(v_{k}\\) (discrete motor commands, discrete sensor readings ‚Ä¶) | Convert the discrete time signal \\(v_{k}\\) to continuous time signal \\(v_t\\), which is fed to continuous plant (G(s)) | The continuous time signal \\(v_t\\) is fed to continuous plant (G(s)) which produces Y(s) | Sample the continuous frequency domain output to get discrete frequency domain output | . ZOH is created by subtracting a delayed step function from another undelayed step function . \\[\\frac{Y(s)}{V{s}}=\\frac{z-1}{z} * \\mathcal{Z}(\\frac{G(s)}{s})|_{t=kT}\\] Using Zero Order Hold in discrete controller design . Model-based design: . | Method 1: Discretize the plant -&gt; design discrete controller. We need to use ZOH . | Everything is represented by discrete transfer functions. | . | Method 2: Design a continuous controller with a continuous plant model -&gt; discretize the controller. ZOH is implied . | Need to use other methods to discretize the continuous controller other than ZOH (Tustin or Matched method) | . | . Notes: . | If you are building a hybrid system with a discrete controller and continuous plant, ZOH is implied. | However, when designing a continuous controller based on continuous plant, ZOH is not assumed. Tuning continuous controller without ZOH effect then discretizing the continuous controller may yield unstable behavior. | A ZOH needs to be explicitly added between controller and plant to ensure the effect of ZOH is taken into account. However, ZOH is nonlinear and classical methods for continuous controllers can‚Äôt handle nonlinearity. | Pad√© Approximation solves this problem by approximating ZOH with a transfer function, allowing us to use classical methods to design the controller then actually discretize it with Tustin method. | . ",
    "url": "/notes/discrete-control.html#discretization-method",
    
    "relUrl": "/notes/discrete-control.html#discretization-method"
  },"33": {
    "doc": "Discrete-Time Control",
    "title": "Bilinear Transform (Tustin Method) - discretizing a continuous controller",
    "content": "The Bilinear Transform is another method for converting a continuous system into a discrete system. Formulae . Bilinear Transform: . \\[s = \\frac{2}{T} \\frac{z-1}{z+1}\\] Inverse Bilinear Transform: . \\[z = \\frac{1+ \\frac{T}{2} s}{1 - \\frac{T}{2}s}\\] **Solving the first formula for s would yield the second one. ",
    "url": "/notes/discrete-control.html#bilinear-transform-tustin-method---discretizing-a-continuous-controller",
    
    "relUrl": "/notes/discrete-control.html#bilinear-transform-tustin-method---discretizing-a-continuous-controller"
  },"34": {
    "doc": "Discrete-Time Control",
    "title": "Why does Binlinear Transform work",
    "content": ". | Interpretation 1: The bilinear transform is essentially a linear first order approximation of \\(z=e^{sT}\\) with Taylor Series. However, rather than \\(z \\approx 1+ ST\\), we use a fraction to better estimate the exponential. To do this, we first split \\(e^{sT} = e^{\\frac{sT}{2}} * e^{\\frac{sT}{2}} = \\frac{e^{\\frac{sT}{2}}}{e^{\\frac{-sT}{2}}}\\). | Interpretation 2: Trapezoidal Integration. | . ",
    "url": "/notes/discrete-control.html#why-does-binlinear-transform-work",
    
    "relUrl": "/notes/discrete-control.html#why-does-binlinear-transform-work"
  },"35": {
    "doc": "Discrete-Time Control",
    "title": "Matched Method (Not widely used!)",
    "content": "This method brings every pole in S domain to Z domain. ",
    "url": "/notes/discrete-control.html#matched-method-not-widely-used",
    
    "relUrl": "/notes/discrete-control.html#matched-method-not-widely-used"
  },"36": {
    "doc": "Discrete-Time Control",
    "title": "Bilinear Transform Mapping",
    "content": "Bilinear Transform warps the s-plane differently than the Z transform described above. In this mapping the three infinities - \\(\\pm \\infty\\) for s-plane imaginary axis and \\(-\\infty\\) for real axis of the s-plane. The imaginarry axis of s-plane wraps around the unit circle. The -1 point is the Nyquist frequency on the z-plane. Frequency Warping Equation . \\(\\omega_d = \\frac{2}{T} atan(\\omega_a \\frac{T}{2})\\) . where \\(\\omega_d\\) is the discrete frequency after bilinear transform and \\(\\omega_a\\) is the analog frequency. At low frequencies, \\(\\omega_a = \\omega_d\\). As frequency increases, the warping becomes bigger. This creates an issue for discretizing continuous filter to get discrete filter. To resolve this issue, we can pre-warp the analog frequency. Pre-warping spec analog frequency (Modified Bilinear Transform) . \\(s = \\frac{\\omega_0}{tan(\\frac{\\omega_0 T}{2})} \\frac{z-1}{z+1}\\) where \\omega_0 is the frequency specification. ",
    "url": "/notes/discrete-control.html#bilinear-transform-mapping",
    
    "relUrl": "/notes/discrete-control.html#bilinear-transform-mapping"
  },"37": {
    "doc": "Discrete-Time Control",
    "title": "Discrete Notch filter design example",
    "content": "Notch filter (Band stop filter) . | Critical frequency \\(\\omega_0\\), center of the notch | Q - how deep and narrow the notch is | . Steps . We first design the filter in continuous domain and craft the perfect analog filter. Then use bilinear transform to deploy the filter on a digital computer. Step 1: Design the filter in continuous domain . Step 2: Pre-warp the critical frequency \\(\\omega_0\\) . Step 3: Use bilinear transform to convert the continuous filter to discrete filter. ",
    "url": "/notes/discrete-control.html#discrete-notch-filter-design-example",
    
    "relUrl": "/notes/discrete-control.html#discrete-notch-filter-design-example"
  },"38": {
    "doc": "Drone Control",
    "title": "Drone Control and Complementary Filter",
    "content": " ",
    "url": "/domain_specific_control/drone.html#drone-control-and-complementary-filter",
    
    "relUrl": "/domain_specific_control/drone.html#drone-control-and-complementary-filter"
  },"39": {
    "doc": "Drone Control",
    "title": "IMU",
    "content": "Gyroscope (Gyro) . | Measures: Angular velocity (rate of rotation) around each axis (x, y, z). | Units: degrees/second (¬∞/s) or radians/second (rad/s). | Strengths: . | Very good at detecting quick, short-term changes in orientation. | Not affected by linear acceleration (e.g., if you shake the sensor). | . | Weaknesses: . | Needs integration to get orientation ‚Üí causes drift over time. | Small constant errors (bias) accumulate when integrated. | . | . 2. Accelerometer . | Measures: Specific force along each axis (x, y, z) ‚Äî includes gravity and linear acceleration. | Units: meters/second¬≤ (m/s¬≤) or g (1 g ‚âà 9.81 m/s¬≤). | Strengths: . | Can give absolute tilt/orientation relative to gravity if stationary or moving slowly. | No drift over time. | . | Weaknesses: . | Very noisy during movement or vibration. | Can‚Äôt distinguish between gravity and actual movement acceleration. | . | . ",
    "url": "/domain_specific_control/drone.html#imu",
    
    "relUrl": "/domain_specific_control/drone.html#imu"
  },"40": {
    "doc": "Drone Control",
    "title": "Continuous Time Complementary Filter",
    "content": "A complementary filter is a simple sensor fusion technique that combines measurements from two (or more) sensors in a way that uses each sensor‚Äôs strengths while compensating for its weaknesses. Complementary Filter Example - Measuring roll with IMU . | Dead Reckoning . | Integrating rate of change at each measurement step by adding it to the current measurement | . | . Many sensors have trade-offs: . Accelerometers: Good at measuring long-term orientation (low-frequency information), but noisy and sensitive to vibration. - Cannot be trusted at a given second. Gyroscopes: Good at measuring short-term changes (high-frequency information), but drift over time. The complementary filter blends them: . Simplified filter diagram in practice: . Low-pass filter the accelerometer ‚Üí keeps slow, long-term trends (reduces noise). High-pass filter the gyroscope ‚Üí keeps fast, short-term changes (reduces drift). ",
    "url": "/domain_specific_control/drone.html#continuous-time-complementary-filter",
    
    "relUrl": "/domain_specific_control/drone.html#continuous-time-complementary-filter"
  },"41": {
    "doc": "Drone Control",
    "title": "Discrete Complementary Filter",
    "content": ". By believe the Gyro more, we are allowing short-term agility to make it through and also adding a small amount of accelerometer data to nudge it back to prevent drifting . ",
    "url": "/domain_specific_control/drone.html#discrete-complementary-filter",
    
    "relUrl": "/domain_specific_control/drone.html#discrete-complementary-filter"
  },"42": {
    "doc": "Drone Control",
    "title": "Drone Control in practice",
    "content": " ",
    "url": "/domain_specific_control/drone.html#drone-control-in-practice",
    
    "relUrl": "/domain_specific_control/drone.html#drone-control-in-practice"
  },"43": {
    "doc": "Drone Control",
    "title": "Sensors",
    "content": ". | Ultrasound sensor - measures altitude or distance above a surface | Camera - measures horizontal motion and speed | Pressure Sensor - Altitude | IMU - Angular rate and Acc | . ",
    "url": "/domain_specific_control/drone.html#sensors",
    
    "relUrl": "/domain_specific_control/drone.html#sensors"
  },"44": {
    "doc": "Drone Control",
    "title": "Hardware",
    "content": "Opposing motors rotate in the same way but different from adjacent motors. This means Thrust, roll, pitch, and yaw can be commanded independently. This design is due to the way yaw interacts with roll and pitch. How to command yaw . To change yaw, slow a pair of motors that spin in the same direction down and speed the other pair up. This will still counteract gravity but total torque is not 0. This Design allows drone to yaw without changing thrust, pitch, or roll. How to command roll . Decrease either left or right pairs of motors spinning in the opposite direction, causing a rolling torque. How to command thrust . Set all motors to the same speed. Motor Mixing Algorithm . Unactuated Directions . Forward, backward, left, and right are unactuated. Maintaining Altitude while going in un-actuated directions . To go left, tilt the drone so its thrust force partially counteracts gravity, partially points left. Increase thrust so the vertical component counteracts gravity completely. ",
    "url": "/domain_specific_control/drone.html#hardware",
    
    "relUrl": "/domain_specific_control/drone.html#hardware"
  },"45": {
    "doc": "Drone Control",
    "title": "Control Diagram",
    "content": ". There are our actuators, four sensors, six degrees of freedom (x, y, z, roll, pitch, yaw). This is an underactuated system. Since we don‚Äôt have an actuator for every motion, some some directions are uncontrollable at any given time. we are going to develop a controller that couples thrust with rotational dynamics . Control Scheme . Plant: Drone . Desired output: hovering at fixed altitude. Design goal: how to manipulate the four actuators to maintain altitude. Why a simple PID for altitude control wouldn‚Äôt work . A PID for altitude (same as thrust) control cannot take into account wind gust and other disturbances. Since increasing thrust can only make the drone travel along its local z axis (pointing down). We therefore needs to ensure a level flight. This motivates the next part. Why a decoupled four-indenpendent-controller control scheme wouldn‚Äôt work . This is undesirable since Reference Pitch and Roll may need to be non-zero while hovering, the drone needs to lean into the wind - wind gust can still cause the drone to drift away from its starting coordinates even though the drone would be level. We need to couple position errors with roll and pitch because left, right, forward, and backward movements are not actuated . ",
    "url": "/domain_specific_control/drone.html#control-diagram",
    
    "relUrl": "/domain_specific_control/drone.html#control-diagram"
  },"46": {
    "doc": "Drone Control",
    "title": "Drone Altitude Controller",
    "content": ". Note: We can command thrust, roll, pitch, and yaw independently. We can thereby create a feedback controller for each one. To ensure the drone doesn‚Äôt drift away from the original (x,y) coordinates due to disturbance, we add a cascade loop for position control. Important notes on Drone Altitude Controller . | We need estimated yaw for position controller, due to the fact that we need to coordinate-transform world coordinate of the starting position to drone body frame. | We have five parameters that require estimates for: yaw, pitch, roll, altitude, (x, y) . | Sensor fuse the 4 sensors we have to estimate. | . | We have 6 PIDs to tune with 4 in cascade. | We need a great model to simulate drone dynamics | . | The position controller takes the position error as input and output roll and pitch. | . ",
    "url": "/domain_specific_control/drone.html#drone-altitude-controller",
    
    "relUrl": "/domain_specific_control/drone.html#drone-altitude-controller"
  },"47": {
    "doc": "Drone Control",
    "title": "Altitude Controller Walkthrough",
    "content": "Scenario starts: Altitude correct, but position is a bit off to the left -&gt; position error. Step 1: P controller of PID request roll angle to fly right, which gives a reference roll angle. Step 2: Inner loop roll PID takes the reference roll angle from previous step and calculate rolling torque. Step 3: Motor-Mix-Algorithm takes rolling torque as input and outputs motor commands, making motors on the left speed up and motors on the right slow down. Scenario prgoresses: Step 3 makes the drone roll to the right, but since the vertical component of the thrust is slightly smaller than gravity when rolled, the drone loses altitude. Step 4: Altitude controller senses this altitude error and increases thrust. Step 5: Position error decreases as drone moves to the right, the requested roll angle also drops. Step 6: Roll PID senses decreases in error, brings drone back to level. ",
    "url": "/domain_specific_control/drone.html#altitude-controller-walkthrough",
    
    "relUrl": "/domain_specific_control/drone.html#altitude-controller-walkthrough"
  },"48": {
    "doc": "Drone Control",
    "title": "Flight code and simulation",
    "content": ". This diagram shows the four components of the Flight Code Software (FCS) . ",
    "url": "/domain_specific_control/drone.html#flight-code-and-simulation",
    
    "relUrl": "/domain_specific_control/drone.html#flight-code-and-simulation"
  },"49": {
    "doc": "Drone Control",
    "title": "Flight code software",
    "content": ". ",
    "url": "/domain_specific_control/drone.html#flight-code-software",
    
    "relUrl": "/domain_specific_control/drone.html#flight-code-software"
  },"50": {
    "doc": "Drone Control",
    "title": "Simulate Flight Dynamics",
    "content": ". | A high fidelity nonlinear model to simulate the real world | A linear model to test linear controllers | . What‚Äôs inside the model block? . ",
    "url": "/domain_specific_control/drone.html#simulate-flight-dynamics",
    
    "relUrl": "/domain_specific_control/drone.html#simulate-flight-dynamics"
  },"51": {
    "doc": "Drone Control",
    "title": "Tuning the PID controller",
    "content": "start with the simplest model possible . | Focus on altitude control only (thrust control) first by setting inputs to MMA for roll, pitch, and yaw to 0 | Assume sensor model plays no role first. | . ",
    "url": "/domain_specific_control/drone.html#tuning-the-pid-controller",
    
    "relUrl": "/domain_specific_control/drone.html#tuning-the-pid-controller"
  },"52": {
    "doc": "Drone Control",
    "title": "Geometric Controller",
    "content": "Reference: . Control 1 Notes (MIT VNAV) . Geometric controller . ",
    "url": "/domain_specific_control/drone.html#geometric-controller",
    
    "relUrl": "/domain_specific_control/drone.html#geometric-controller"
  },"53": {
    "doc": "Drone Control",
    "title": "Inputs and Outputs of the Geometric Controller",
    "content": "Inputs . | Desired state \\(p_{d}^{w}, \\tilde{x}_{d}^{w}\\), and current state \\(x, \\dot{x}, R, \\omega\\). Compute Tracking Error. | Positive Constants \\(K_p (\\text{ or } K_{x}), K_v, K_R, K_\\omega\\), for gains. | Vehicle params: mass m, inertia J, gravity g. | . Outputs of the Geometric Controller . | Collective thrust (scalar), a force along body (\\(b_3\\)) | Body moments(vector) \\(M \\in \\mathcal{R}^3\\) | . ",
    "url": "/domain_specific_control/drone.html#inputs-and-outputs-of-the-geometric-controller",
    
    "relUrl": "/domain_specific_control/drone.html#inputs-and-outputs-of-the-geometric-controller"
  },"54": {
    "doc": "Drone Control",
    "title": "Tracking Error",
    "content": ". | Position error \\(e_p = p_w - p_w^d\\) . | Linear velocity error \\(e_v = v_w - v_w^d\\) . | Rotation error \\(e_R = \\frac{1}{2} \\left[ (R_w^d)^T R_w^B - (R_w^B)^T R_w^d \\right]^\\vee\\) . | Angular velocity error \\(e_\\omega = \\omega_B - (R_w^B)^T R_w^d \\, \\omega_d\\) . | . ",
    "url": "/domain_specific_control/drone.html#tracking-error",
    
    "relUrl": "/domain_specific_control/drone.html#tracking-error"
  },"55": {
    "doc": "Drone Control",
    "title": "Control commands (per tick)",
    "content": "Translational Side . Let \\(R \\in SO(3)\\) be the body‚Üíworld rotation matrix, \\(\\Omega \\in \\mathbb{R}^3\\) the body-frame angular velocity, \\(e_3 = [0,\\,0,\\,1]^\\top\\), \\(m\\) the mass, \\(J\\) the inertia matrix. Position/velocity errors: \\(e_p = x - x_d, \\quad e_v = \\dot{x} - \\dot{x}_d\\) . Commanded acceleration: \\(a_c = -K_p e_p - K_v e_v + g\\,e_3 + \\ddot{x}_d\\) . Collective thrust: \\(u_1 = m\\, a_c^\\top (R\\,e_3)\\) . Rotational Side . Attitude/angular velocity errors: \\(e_R = \\frac{1}{2} \\big(R_d^\\top R - R^\\top R_d\\big)^\\vee\\), \\(e_\\Omega = \\Omega - R^\\top R_d \\,\\Omega_d\\) . Moment command: \\(M = -K_R e_R - K_\\Omega e_\\Omega + \\Omega \\times (J\\Omega) - J\\left( \\hat{\\Omega} R^\\top R_d \\Omega_d - R^\\top R_d \\dot{\\Omega}_d \\right)\\) . Where: . | \\((\\cdot)^\\wedge\\) is the hat map: \\(\\hat{a}b = a \\times b\\) | \\((\\cdot)^\\vee\\) is the inverse of the hat map | . ",
    "url": "/domain_specific_control/drone.html#control-commands-per-tick",
    
    "relUrl": "/domain_specific_control/drone.html#control-commands-per-tick"
  },"56": {
    "doc": "Drone Control",
    "title": "Geometric Controller Tuning Guide",
    "content": "Step A ‚Äì Attitude Loop Gains (\\(k_R\\), \\(k_Œ©\\)) . Goal: Make the vehicle track attitude commands quickly and without overshoot. | Freeze position loop: . | Hold position constant or give manual attitude commands. | . | Initial values: . | Start small so the response is gentle. | Example starting point: \\(k_R ‚âà 8 * J_{diag} k_Œ© ‚âà 2 * sqrt(k_R * J_{diag})\\) where \\(J_{diag}\\) are diagonal elements of the inertia matrix. | . | Tune \\(k_R\\): . | Increase until rotations toward commanded attitude are crisp but not oscillatory. | . | Tune \\(k_Œ©\\): . | Increase to damp rotation overshoot (derivative-like effect). | . | Target: . | Step response in ~0.2‚Äì0.4 s, no sustained oscillations. | Watch for motor torque saturation. | . | . Step B ‚Äì Position Loop Gains (\\(k_x\\), \\(k_v\\)) . Goal: Track position without excessive attitude demands or overshoot. | Fix attitude loop: . | Keep \\(k_R\\) and \\(k_Œ©\\) from Step A. | . | Start small: . | Small \\(k_x\\) for gentle acceleration toward waypoint. | Add \\(k_v\\) to damp oscillations. | . | Increase \\(k_x\\): . | Raise until position response is as fast as desired without saturating thrust. | . | Tune \\(k_v\\): . | For near-critical damping: \\(k_v ‚âà 2 * \\sqrt{(k_x * m)}\\) where \\(m\\) is the mass. | . | . ",
    "url": "/domain_specific_control/drone.html#geometric-controller-tuning-guide",
    
    "relUrl": "/domain_specific_control/drone.html#geometric-controller-tuning-guide"
  },"57": {
    "doc": "Drone Control",
    "title": "Drone Control",
    "content": " ",
    "url": "/domain_specific_control/drone.html",
    
    "relUrl": "/domain_specific_control/drone.html"
  },"58": {
    "doc": "Drone Control Interview Prep",
    "title": "Q1: The drone starts oscillating in pitch right after you increase the control gain on PID. What do you check? How do you restore stability?",
    "content": "1. Triage: . Almost always caused by excessively high gains. | Actuator limits: If you‚Äôre near saturation or hitting rate limits, that can create oscillations or limit cycles. | Sign/Wiring check: Ensure control sign hasn‚Äôt flipped (positive feedback will cause instant oscillation). | Sensor sanity: Verify steering angle measurement is valid and not noisy. | Latency: Check comms or control loop timing - extra delay can destabilize a loop even at the same gain. | . 2. Diagnosis - Why gain change caused oscillation . | Increasing Kp shifts the gain crossover frequency higher, which usually reduces phase margin. | Reduced phase margin ‚Üí system is closer to the -180¬∞ phase point when magnitude crosses 0 dB ‚Üí oscillation. | . 3. Action plan ‚Äî How to restore stability . | Quick fix: Lower Kp back down until oscillation stops, then re-tune more conservatively. | Improve phase margin: Add phase lead at high frequencies to recover margin at the new crossover. Increase loop bandwidth gradually while monitoring margins. | Filter noise: If derivative gain adds noise, use a small low-pass filter on the measurement. | . ",
    "url": "/interview_prep/drone_control.html#q1-the-drone-starts-oscillating-in-pitch-right-after-you-increase-the-control-gain-on-pid-what-do-you-check-how-do-you-restore-stability",
    
    "relUrl": "/interview_prep/drone_control.html#q1-the-drone-starts-oscillating-in-pitch-right-after-you-increase-the-control-gain-on-pid-what-do-you-check-how-do-you-restore-stability"
  },"59": {
    "doc": "Drone Control Interview Prep",
    "title": "Drone Control Interview Prep",
    "content": " ",
    "url": "/interview_prep/drone_control.html",
    
    "relUrl": "/interview_prep/drone_control.html"
  },"60": {
    "doc": "Frequency Response and Fourier Transform",
    "title": "Frequency Response and Fourier Transform",
    "content": " ",
    "url": "/notes/frequency-response.html",
    
    "relUrl": "/notes/frequency-response.html"
  },"61": {
    "doc": "Frequency Response and Fourier Transform",
    "title": "Quick Notes on Damping",
    "content": "Underdamped, Critically damped, and Overdamped . Underdamped: imgarinary poles . Cirtically damped: repeated poles (eigenvalues) . Overdamped: Real eigenvalues . For a standard second-order transfer function: . \\[G(s) = \\frac{\\omega_n^2}{s^2 + 2\\zeta \\omega_n s + \\omega_n^2}\\] For a standard second-order system: . \\[\\ddot{y}(t) + 2\\zeta \\omega_n \\dot{y}(t) + \\omega_n^2 y(t) = K \\omega_n^2 u(t)\\] . The standard second-order system in differential equation form is: . \\[\\ddot{y}(t) + 2\\zeta \\omega_n \\dot{y}(t) + \\omega_n^2 y(t) = K \\omega_n^2 u(t)\\] 1. Underdamped (\\(0 &lt; \\zeta &lt; 1\\)): . \\[y(t) = e^{-\\zeta \\omega_n t} \\left[ A \\cos\\left( \\omega_n \\sqrt{1 - \\zeta^2} \\, t \\right) + B \\sin\\left( \\omega_n \\sqrt{1 - \\zeta^2} \\, t \\right) \\right]\\] Critically damped (\\(\\zeta = 1\\)): . \\[y(t) = \\left( A + Bt \\right) e^{-\\omega_n t}\\] Overdamped (\\(\\zeta &gt; 1\\)): . Let: \\(r_{1,2} = -\\omega_n \\left( \\zeta \\pm \\sqrt{\\zeta^2 - 1} \\right)\\) . Then: \\(y(t) = A e^{r_1 t} + B e^{r_2 t}\\) . Damping in higher order systems . Damping behavior is only defined for second order systems. Dominant poles are investigated for general behavior for higher-order systems. Damping and Bode plot . A peak in the frequency response (magnitude plot) happens when the system has complex conjugate poles that are lightly damped. ",
    "url": "/notes/frequency-response.html#quick-notes-on-damping",
    
    "relUrl": "/notes/frequency-response.html#quick-notes-on-damping"
  },"62": {
    "doc": "Frequency Response and Fourier Transform",
    "title": "Fourier and Laplace Transforms",
    "content": "Note: In Laplace domain, \\(s=\\sigma + j\\omega\\). When evaluating Laplace Transform at \\(s=j\\omega\\), Laplace Transform becomes Fourier Transform. when you go from the Laplace transform \\(F(s)\\) to the Fourier transform \\(F(j\\omega)\\), you‚Äôre essentially looking at the steady-state sinusoidal response of the system. Laplace Transform . \\(\\mathcal{L}\\{f(t)\\} = F(s) = \\int_0^{\\infty} e^{-st} f(t) \\, dt\\) . Laplace Tranform is a generialized form of Fourier Transform. Specifically, Fourier Transform evaluates Laplace Transform at \\(i\\omega\\), with no real parts, ie. Fourier Transform only evaluates purely imaginary arguments for Laplace Transform. Inpoulse response h(t) given \\(u = \\delta(t)\\) is \\(L^{-1}{G(s), where Y(s) = G(s)X(s)}\\) ie the inverse Laplace Transform of the Transfer function (G(s)) . Fourier Series . If \\(f(t)\\) is a periodic function with period $T$, its Fourier series representation is: . \\[f(t) = a_0 + \\sum_{n=1}^{\\infty} \\left[ a_n \\cos\\left(\\frac{2\\pi n t}{T}\\right) + b_n \\sin\\left(\\frac{2\\pi n t}{T}\\right) \\right]\\] The coefficients are given by: . \\[a_0 = \\frac{1}{T} \\int_{-T/2}^{T/2} f(t) \\, dt\\] \\[a_n = \\frac{2}{T} \\int_{-T/2}^{T/2} f(t) \\cos\\left(\\frac{2\\pi n t}{T}\\right) dt\\] \\[b_n = \\frac{2}{T} \\int_{-T/2}^{T/2} f(t) \\sin\\left(\\frac{2\\pi n t}{T}\\right) dt\\] You can also write the Fourier series using complex exponentials: . \\[f(t) = \\sum_{n=-\\infty}^{\\infty} c_n e^{i 2\\pi n t / T}\\] with coefficients: . \\[c_n = \\frac{1}{T} \\int_{-T/2}^{T/2} f(t) e^{-i 2\\pi n t / T} dt\\] . Fourier Transform . For non-periodic functions, the Fourier Transform is used. The continuous-time Fourier transform (CTFT) of a function $f(t)$ is: . \\[F(\\omega) = \\int_{-\\infty}^{\\infty} f(t) e^{-i \\omega t} dt\\] The inverse Fourier transform is: . \\[f(t) = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} F(\\omega) e^{i \\omega t} d\\omega\\] Alternatively, in terms of frequency \\(f\\) (Hz) instead of angular frequency $\\omega = 2\\pi f$: . \\[F(f) = \\int_{-\\infty}^{\\infty} f(t) e^{-i 2\\pi f t} dt\\] \\[f(t) = \\int_{-\\infty}^{\\infty} F(f) e^{i 2\\pi f t} df\\] Intuition Fourier Transform converts a time-domain \\(\\bar{x}(t)\\) to frequency domain \\(X(f)\\). This investigates how much of this specific frequency exists in the signal. Fourier Transform returns a complex number. | The magnitude of this number denotes how strong that frequency is in the signal | The angle of the complex number signifies the phase offset of that frequency - i.e., where that sine wave starts relative to time zero. | . ",
    "url": "/notes/frequency-response.html#fourier-and-laplace-transforms",
    
    "relUrl": "/notes/frequency-response.html#fourier-and-laplace-transforms"
  },"63": {
    "doc": "Frequency Response and Fourier Transform",
    "title": "Non-minimum Phase",
    "content": "Motivation: For the same magnitude gain plot, phase plots can be drastically different. This is due to the fact that multiple transfer functions can produce the same magnitude gain plot, but have different phase profiles. Note: Non-miminum phase can be primarily caused by three phenomena: 1. Time delay \\(e^{-sT}\\) 2. RHP zeroes 3. Non-causal/Inverse-unstable Dynamics (Non-causal systems depend on input in the future) . Inverse-unstable systems (RHP in zero -&gt; inverse system has RHP pole (unstable inverse)) . Green curve is for time delay, and red curve is for RHP zero. Why does RHP zeroes cause system to go the opposite way first . Long story short, RHP zeroes take derivative on the input with the \\(-S\\) term, which means the derivative has opposite sign from the input, which causes the system to react in the opposite way before correcting. ",
    "url": "/notes/frequency-response.html#non-minimum-phase",
    
    "relUrl": "/notes/frequency-response.html#non-minimum-phase"
  },"64": {
    "doc": "Frequency Response and Fourier Transform",
    "title": "Why is RHP zero undesirable and what makes it hard to control",
    "content": ". | Moving in the opposite way first slows down the response . | Increasing the controller gain can make it unstable. (cart keeps going to the left initially because of increased error, which causes increased control effort, which in turn makes the cart keep going in the wrong way before full throttle to the right.) . | NMP systems have smaller phase margins because of the additional phase lag. | NMP systems are more susceptible to the gain. Increasing the gain increases the gain crossover frequency, which decreases phase margin. | . RHP examples . | Inverted pendulum: System: x coordinate of the cart. behavior: the cart goes left first, causing the pendulum to to slightly right, before moving right again and causing the pendulum to balance. | Aircraft altitude control: System: altitude of the aircraft. behavior: to gain altitude, the aircraft needs to drop the elevator first before rising. | . How to deal with RHP zeroes with controller . | Having a pole in the controller that cancels out the zero in the plant is risky since the output of the controller can be unbounded even though the output of the plant (the entire system) can be stable. | Predictive or nonlinear controllers . | Easiest: lower controller gain to maintain stability and increase phase margin. | . ",
    "url": "/notes/frequency-response.html#why-is-rhp-zero-undesirable-and-what-makes-it-hard-to-control",
    
    "relUrl": "/notes/frequency-response.html#why-is-rhp-zero-undesirable-and-what-makes-it-hard-to-control"
  },"65": {
    "doc": "Frequency Response and Fourier Transform",
    "title": "Bode and Nyquist Plots",
    "content": "Frequency Response . \\(frac{\\bar{x}}{\\bar{u}}\\) Notes: . | The bode plots are plotted in log scale. A small bump in Gain plot corresponds to huge response at resonate frequency. | At extremely low frequency, this system displays no gain at all hence Gain = 0 for low frequencies. At high frequencies, the sytems doesn‚Äôt have the capacity to respond in times hence the gain drops asymptotically to zero or $-\\infty$ in log scale. | . ",
    "url": "/notes/frequency-response.html#bode-and-nyquist-plots",
    
    "relUrl": "/notes/frequency-response.html#bode-and-nyquist-plots"
  },"66": {
    "doc": "General Interview Prep",
    "title": "How does rate limiting and actuator saturation affect stability?",
    "content": "Both introduce nonlinear effects that can significantly influence a control system‚Äôs stability and performance. Actuator Saturation . | Loss of Phase Margin: we assume actuator perfectly tracks the commanded signal. Often increaes effective delay and reduce stability margins | Integral wind-up. The integral term keeps accumulating even though motors are saturated. | Limit Cycles. | . How to resolve: . | Integrator clamping for anti-windup. | Gain scheduling | . Rate Limiting . The actuator can only change its output at a limited rate (slew rate) . | Effective delay: Rate limitting effectively adds delay to the system, introducing phase lag - slows down the system‚Äôs ability to respond. | Reduced damping: In high-gain systems phase lag can push phase margin close to zero, making the system oscillatory. | Reduced bandwidth: cannot track higher frequency reference signals. | . ",
    "url": "/interview_prep/general.html#how-does-rate-limiting-and-actuator-saturation-affect-stability",
    
    "relUrl": "/interview_prep/general.html#how-does-rate-limiting-and-actuator-saturation-affect-stability"
  },"67": {
    "doc": "General Interview Prep",
    "title": "You perceived overshoot in your system. What are the causes and what do you do?",
    "content": "There are several potential causes of overshoot: . | Low damping: reducing \\(K_p\\) and increasing \\(K_d\\) | Integral Windup (Integral term too high): anti-windup | . ",
    "url": "/interview_prep/general.html#you-perceived-overshoot-in-your-system-what-are-the-causes-and-what-do-you-do",
    
    "relUrl": "/interview_prep/general.html#you-perceived-overshoot-in-your-system-what-are-the-causes-and-what-do-you-do"
  },"68": {
    "doc": "General Interview Prep",
    "title": "Effects of PID on Bandwidth",
    "content": "Kp . Increasing the proportional gain generally increases the bandwidth because it amplifies the response to changes in the error signal, allowing the system to react more quickly to disturbances or reference changes. Limitations: Higher gain correspond to smaller phase margin. High Kp can cause the system to become oscillatory or unstable. ",
    "url": "/interview_prep/general.html#effects-of-pid-on-bandwidth",
    
    "relUrl": "/interview_prep/general.html#effects-of-pid-on-bandwidth"
  },"69": {
    "doc": "General Interview Prep",
    "title": "General Interview Prep",
    "content": " ",
    "url": "/interview_prep/general.html",
    
    "relUrl": "/interview_prep/general.html"
  },"70": {
    "doc": "Nichols Chart, Nyquist Plot, Bode Plot, and Root Locus Plot",
    "title": "Nichols Chart, Nyquist Plot, and Bode Plot",
    "content": ". All three plots display 3 Key information about the system: 1. Gain 2. Phase 3. Frequency . ",
    "url": "/notes/important_plots.html#nichols-chart-nyquist-plot-and-bode-plot",
    
    "relUrl": "/notes/important_plots.html#nichols-chart-nyquist-plot-and-bode-plot"
  },"71": {
    "doc": "Nichols Chart, Nyquist Plot, Bode Plot, and Root Locus Plot",
    "title": "Which to Use? A comparison",
    "content": "All three display the same information just in different ways Bode Plot is useful for Loop shaping. Nyquist Plot and Nichols Plot are useful for general sensitivity and stability analysis. ",
    "url": "/notes/important_plots.html#which-to-use-a-comparison",
    
    "relUrl": "/notes/important_plots.html#which-to-use-a-comparison"
  },"72": {
    "doc": "Nichols Chart, Nyquist Plot, Bode Plot, and Root Locus Plot",
    "title": "Intuition",
    "content": "Bode plot is extremely useful when analyzing open loop frequency reponse \\(G(s)\\) of minimum phase and stable systems to predict the beahvior of the closed loop system \\(\\frac{G(s)}{1+G(s)}\\). However, Bode plot falls apart when dealing with non-minimum phase or unstable systems. This is where Nyquist plot comes in useful. Nyquist plot displays all three in one plot (Gain, Phase, Frequency). Nichols encodes Bode magnitude and phase plots into one single plot, displaying same information as the Nyquist plot in cartesian coordinates. ",
    "url": "/notes/important_plots.html#intuition",
    
    "relUrl": "/notes/important_plots.html#intuition"
  },"73": {
    "doc": "Nichols Chart, Nyquist Plot, Bode Plot, and Root Locus Plot",
    "title": "Nyquist Plot",
    "content": ". Important Notes on Nyquist Plot . | If the open loop system is stable (ie. \\(L(s)\\) doesn‚Äôt have any RHP poles), Nyquist plot should not encircle -1 and if it does, it means the closed loop system is unstable. | If the open loop system is unstable (ie. there are RHP poles), Nyquist plot needs to encircle the -1 point \\(N = Z - P\\) times clockwise. This way the closed loop system is stable and the open loop system is called stabilizable. | For a strictly proper or non-strictly proper transfer function, all infinite points not on the imaginary axis on the S-plane are mapped to one single point on the W-plane | For strictly proper systems, that point is the origin. | For nonstrictly proper systems, that point is a non-zero constant with no phase ie the point lies on the positive x-axis. | . Nyquist Plot Stability analysis (benefits) . | for minimum phase and stable open loop systems, don‚Äôt corss the cricitical point (-1,0) | Gain margin and Phase Margin can be read from Nyquist Plot | We can still use Nyquist Stability Criterion and Nyquist plot even for unstable open loop systems | Easier to see combinations of gain and phase (disk margin) | Information displayed in polar coordinates. | . Nyquist Plot Critical Point . Avoid (-1,0) on Nyquist plot if the system is open-loop stable. Closed-loop system oscillates at that point (marginally stable). Nyquist Plot Intuition . Nyquist plot is the plot in the W-plane resulting from a transfer function mapping the Nyquist contour on the S-plane to a plot on the W plane. In the S-plane, for proper and strictly proper transfer functions all RHP infinite points (not on the imaginary axis) are mapped to a single point in W-plane since in W-plane . \\[\\text{Phasor Magnitude} \\propto \\frac{\\Pi \\text{magnitude of zero phasors in s}}{\\Pi \\text{magnitude of pole phasors in s}}\\] . | For a strictly proper transfer function (number of zeros &lt; number of poles), this point is the origin. | For a proper transfer function (number of zeros = number of poles), this point is a non-zero constant real value. | . Plotting Nyquist plot by hand . Step 1: Substituting \\(s=j \\omega\\) into the give transfer function. Step 2: Sweep \\(\\omega\\) from 0 to \\(\\infty\\). Step 3: Draw its reflection about the real axis in W-plane for negative frequencies (in S-plane). Step 2 frequency sweeping walkthrough: . We can use 4 points to approximate this. | \\[\\omega = 0\\] | \\[\\omega = \\infty\\] | Imaginary intercepts | Real intercepts | . To get the intercepts in 3 and 4, follow these steps: . | Substituting \\(s=j \\omega\\) into the give transfer function. | Factor out the real components and the imaginary components. | Set real part to 0 for imaginary intercepts. | Set imaginary part to 0 for real intercepts. | . Nyquist Plot Use cases . A fighter jet open loop system has one slightly positve real pole which makes the system slightly unstable (by design). Bode plot doesn‚Äôt work on this scenario, but Nyquist plot can help. Count the number of CW encirclements of -1! . ",
    "url": "/notes/important_plots.html#nyquist-plot",
    
    "relUrl": "/notes/important_plots.html#nyquist-plot"
  },"74": {
    "doc": "Nichols Chart, Nyquist Plot, Bode Plot, and Root Locus Plot",
    "title": "Nichols Plot",
    "content": "Frequency is not explicitly shown just as Nyquist plot . ",
    "url": "/notes/important_plots.html#nichols-plot",
    
    "relUrl": "/notes/important_plots.html#nichols-plot"
  },"75": {
    "doc": "Nichols Chart, Nyquist Plot, Bode Plot, and Root Locus Plot",
    "title": "Applications",
    "content": "System Identification with Bode Plot . Given a blackbox LTI system, feeding in signals of various frequency (Sine sweep) and observing the output can generate the bode plot of the transfer function. System Design and Analysis with Bode plot . Fundamental Principle: Open loop system can provide insightful information about the close loop system. Let open loop system = G(s) = L(s) = P(s) * K(s), closed loop system = \\(\\frac{G(s)}{1+G(s)}\\) . Applications of Bode plot . | If \\(G(s)\\), an open loop system transfer function has any 0 dB and -180 degrees phase frequencies (G(s)=-1+0j), then closed loop \\(\\frac{G(s)}{1+G(s)}\\) will oscillate. Bode plot can be used to check. | If open loop system is miminum phase and stable, (both zeroes poles are on the LHP), then we can determine closed loop easily through bode plot | . Key Observation Bode-plot restatements of Nyquist Criterion (margins) . Let \\(\\omega_{gc}\\) be a gain-crossover frequency where \\(|G(j\\omega_{gc})|=1\\) , and let \\(\\omega_{pc}\\) be a phase-crossover frequency where \\(\\angle G(j\\omega_{pc})=-180^\\circ\\). | Phase margin condition (at gain crossover): \\(|G(j\\omega_{gc})|=1 \\quad \\Rightarrow \\quad \\angle G(j\\omega_{gc}) &gt; -180^\\circ\\) (positive phase margin). This ensures the Nyquist plot does not cross the real axis at or left of \\(-1\\). | Gain margin condition (at phase crossover): \\(\\angle G(j\\omega_{pc})=-180^\\circ \\quad \\Rightarrow \\quad |G(j\\omega_{pc})| &lt; 1\\) (positive gain margin). This keeps the Nyquist locus inside the unit circle when it is at \\(-180^\\circ\\), avoiding the point \\(-1\\). | . If both conditions hold for all relevant crossovers and \\(P=0\\), the loop has positive stability margins and the closed loop is stable. ",
    "url": "/notes/important_plots.html#applications",
    
    "relUrl": "/notes/important_plots.html#applications"
  },"76": {
    "doc": "Nichols Chart, Nyquist Plot, Bode Plot, and Root Locus Plot",
    "title": "Nichols Chart, Nyquist Plot, Bode Plot, and Root Locus Plot",
    "content": " ",
    "url": "/notes/important_plots.html",
    
    "relUrl": "/notes/important_plots.html"
  },"77": {
    "doc": "Control Notes",
    "title": "üß† Control Notes",
    "content": "Welcome to my personal collection of control systems notes. This site compiles essential topics, explanations, and formulas for quick reference and deeper learning. ",
    "url": "/#-control-notes",
    
    "relUrl": "/#-control-notes"
  },"78": {
    "doc": "Control Notes",
    "title": "üìö Core Topics",
    "content": "Linear Control . | Useful Tips Important Intuitions for designing control systems. | Overview A comparison between Open Loop control and Closed Loop control, and categorizing controllers. | Design Workflow Typical design requirements and design actions. | Plot Reviews Review Nichols Chart, Nyquist Plot, Bode Plot, and Root Locus Plot. | Performance Specifications Rise time, settling time, overshoot, Steady-State Error (error constants, system type, examples). | System ID Linear, Nonlinear, Online and recursive system identification. | Stability Analysis Routh-Hurwitz, Nyquist, Lyapunov methods and practical insights. | Sensor Fusion Common Sensor Fusion algorithms. | PID Control Overview of Proportional-Integral-Derivative control, tuning methods, use cases. | Lead, Lag, and Lead-Lag Compensators Frequency domain intuition, Bode plot effects, stability and performance improvement. | Root Locus Analysis Pole-zero placement and visualizing the impact of controller design. | Optimal Pole Placement in Linear Systems Introduces LQR and pole placement. | State Observers Linear quadratic Estimator and Observability. | Controllability and Reachability Illustrates the equivalence between controllability and reachability. | Frequency Analysis and Fourier Transform How to interpret system behavior in the frequency domain, including Fourier Transform and Bode Plots. Non-minimum phase . | Sensitivity, Robustness, and Robust Control Sensitive, complimentary Sensitivity, and robust control techniques. | Discrete-Time Control Z-transform, digital implementation of controllers, sampling effects. | Model Predictive Control (MPC) Optimization-based control for constrained systems (intro-level overview). | SVD . | Data Driven Control Advanced control topics for Machine Learning based control . | . Nonlinear Control . | Lyapunov Stability Principle | . ",
    "url": "/#-core-topics",
    
    "relUrl": "/#-core-topics"
  },"79": {
    "doc": "Control Notes",
    "title": "Domain Specific Control",
    "content": ". | Quadcoptor Control . | Autonomous Cars . | . ",
    "url": "/#domain-specific-control",
    
    "relUrl": "/#domain-specific-control"
  },"80": {
    "doc": "Control Notes",
    "title": "Interview Prep",
    "content": ". | Kodiak Autonomous Trucking . | Drone Control . | . ",
    "url": "/#interview-prep",
    
    "relUrl": "/#interview-prep"
  },"81": {
    "doc": "Control Notes",
    "title": "Data Driven Control",
    "content": ". | [] | . ",
    "url": "/#data-driven-control",
    
    "relUrl": "/#data-driven-control"
  },"82": {
    "doc": "Control Notes",
    "title": "üõ†Ô∏è Tools and Techniques",
    "content": ". | Control System Design Workflow From modeling to simulation to real-world tuning. | Control Using Simulink &amp; Python Practical guides using Simulink, Python (control, matplotlib, etc.). | . Made using Jekyll . ",
    "url": "/#%EF%B8%8F-tools-and-techniques",
    
    "relUrl": "/#Ô∏è-tools-and-techniques"
  },"83": {
    "doc": "Control Notes",
    "title": "Control Notes",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"84": {
    "doc": "Kodiak Autonomous Trucking",
    "title": "Q1: Your GNSS feed drops for 5 seconds, but you still have IMU data. How would you keep the state estimate stable during that time? Which estimation technique(s) would you use and why?",
    "content": "When GNSS drops, I‚Äôd rely on high-rate inertial data for short-term state propagation. The IMU provides fast gyroscope and accelerometer updates; gyros give smooth angular rate but drift over time, while accelerometers are noisy but drift-free. I‚Äôd use an Extended Kalman Filter to fuse the IMU with any other available aiding sensors ‚Äî like magnetometer for yaw reference ‚Äî and explicitly model sensor biases for gyro, accel, and magnetometer in the state vector. During the dropout, the EKF runs in prediction mode, essentially doing dead reckoning. For a ground vehicle, I might also constrain motion with wheel odometry or nonholonomic constraints to reduce drift. The state would include pose, velocity, accelerations, and sensor biases ‚Äî about 25‚Äì30 states in my case ‚Äî so when GNSS returns, the filter can quickly correct accumulated drift. ## . ",
    "url": "/interview_prep/kodiak.html#q1-your-gnss-feed-drops-for-5-seconds-but-you-still-have-imu-data-how-would-you-keep-the-state-estimate-stable-during-that-time-which-estimation-techniques-would-you-use-and-why",
    
    "relUrl": "/interview_prep/kodiak.html#q1-your-gnss-feed-drops-for-5-seconds-but-you-still-have-imu-data-how-would-you-keep-the-state-estimate-stable-during-that-time-which-estimation-techniques-would-you-use-and-why"
  },"85": {
    "doc": "Kodiak Autonomous Trucking",
    "title": "Kodiak Autonomous Trucking",
    "content": " ",
    "url": "/interview_prep/kodiak.html",
    
    "relUrl": "/interview_prep/kodiak.html"
  },"86": {
    "doc": "Linear Control Schemes - LQG",
    "title": "Important Control Schemes",
    "content": " ",
    "url": "/notes/linear_control_scheme.html#important-control-schemes",
    
    "relUrl": "/notes/linear_control_scheme.html#important-control-schemes"
  },"87": {
    "doc": "Linear Control Schemes - LQG",
    "title": "Linear Quadratic Gaussian (Optimal Control)",
    "content": "where $w$ is the dynamics white noise and $v$ is the external disturbance white noise . Separation Principle . If (A, B) is controllable and (A, C) is observable, then LQE and LQR can be seperately optimized then put together while preserving stability. However, this can lead the system to be non-robust sometimes. ",
    "url": "/notes/linear_control_scheme.html#linear-quadratic-gaussian-optimal-control",
    
    "relUrl": "/notes/linear_control_scheme.html#linear-quadratic-gaussian-optimal-control"
  },"88": {
    "doc": "Linear Control Schemes - LQG",
    "title": "Linear Control Schemes - LQG",
    "content": " ",
    "url": "/notes/linear_control_scheme.html",
    
    "relUrl": "/notes/linear_control_scheme.html"
  },"89": {
    "doc": "Model Predictive Control",
    "title": "Model Predictive Control (MPC)",
    "content": " ",
    "url": "/notes/mpc.html#model-predictive-control-mpc",
    
    "relUrl": "/notes/mpc.html#model-predictive-control-mpc"
  },"90": {
    "doc": "Model Predictive Control",
    "title": "Model Predictive Control",
    "content": " ",
    "url": "/notes/mpc.html",
    
    "relUrl": "/notes/mpc.html"
  },"91": {
    "doc": "Open loop vs closed loop control",
    "title": "Categorizing controllers",
    "content": " ",
    "url": "/notes/overview.html#categorizing-controllers",
    
    "relUrl": "/notes/overview.html#categorizing-controllers"
  },"92": {
    "doc": "Open loop vs closed loop control",
    "title": "Classical (Transfer Function-Based) Controllers",
    "content": ". | PID - most common in industry, time/frequency-domain based. | Use when: . | Plant dynamics are reasonable well-behaved (not too nonlinear not too fast) | No full state-space model (just input-output data) | Need something simple, reliable, and easy to tune | . | . | Lead-Lag Compensators ‚Äì designed using Bode/Nyquist plots. | Use when: . | You want to shape frequency response to improve stability margins or transient response | You‚Äôre working in frequency domain (Bode Nyuquist) | . | . | Notch filters -suppress certain frequencies. | . ",
    "url": "/notes/overview.html#classical-transfer-function-based-controllers",
    
    "relUrl": "/notes/overview.html#classical-transfer-function-based-controllers"
  },"93": {
    "doc": "Open loop vs closed loop control",
    "title": "State-Space Controllers",
    "content": ". | LQR and LQI . | Use when: . | You have a full state-space model (A, B matices) | Need optimal trade-off between control effort and performance | The system is MIMO | . | . | LQG - LQR + Kalman for output feedback . | Use when: . | Same as LQR but not all states are measurable | Need optimal performance with noisy sensors | . | . | Pole Placement - place closed-loop poles via state feedback . | Use when: . | You want specific transient dynamics (settling time, damping, overshoot). | Model is known in state-space form | . | . | MPC . | Use when: . | Need to handle constraints (actuator limits, safety boundaries) | Computational resources are available | . | . | . ",
    "url": "/notes/overview.html#state-space-controllers",
    
    "relUrl": "/notes/overview.html#state-space-controllers"
  },"94": {
    "doc": "Open loop vs closed loop control",
    "title": "Adaptive &amp; Nonlinear Controllers",
    "content": ". | Model Reference Adaptive Control (MRAC) ‚Äì adapts gains in real time. | Use when: Plant dynamics change over time or are partially unknown | . | Sliding Mode Control - robust to disturbances, discontinuous control law . | Use when: You need robustness against large uncertainties/disturbances | . | Feedback Linearization ‚Äì cancels nonlinearities with nonlinear control law. | Use when: System is strongly nonlinear but exact model is known. | . | Backstepping - recursive Lyapunov-based design . | Use when: dynamics are too complex or unkown for modeling | . | . ",
    "url": "/notes/overview.html#adaptive--nonlinear-controllers",
    
    "relUrl": "/notes/overview.html#adaptive--nonlinear-controllers"
  },"95": {
    "doc": "Open loop vs closed loop control",
    "title": "Data-Driven Modern AI controllers",
    "content": ". | RL controllers -learn optimal policies from data | Neural network controllers | . ",
    "url": "/notes/overview.html#data-driven-modern-ai-controllers",
    
    "relUrl": "/notes/overview.html#data-driven-modern-ai-controllers"
  },"96": {
    "doc": "Open loop vs closed loop control",
    "title": "Open Loop vs Closed Loop Control",
    "content": "Why feedback control? . | Uncertainty (inherent in the system) in open loop system dynamics. Preplanned control inputs may fall flat against uncertainties. | Instability of the open loop system cann never be dealt with by open loop control. Feedback control allows us to directly change the dynamics of the system, inlcuding the eigenvalues of the system. | Disturbances (external forces) can be rejected by feedback. | Energy and efficiency. | . ",
    "url": "/notes/overview.html#open-loop-vs-closed-loop-control",
    
    "relUrl": "/notes/overview.html#open-loop-vs-closed-loop-control"
  },"97": {
    "doc": "Open loop vs closed loop control",
    "title": "Fixing Instability with Pole Placement",
    "content": "\\(\\dot{x}=Ax + Bu\\), \\(y=Cx\\), let \\(u=-Kx\\), \\(\\dot{x}=Ax-BKx=(A-BK)x\\) We are able to change the actual dynamics of the system to stabilize it by selecting appropriate \\(B*K\\). ",
    "url": "/notes/overview.html#fixing-instability-with-pole-placement",
    
    "relUrl": "/notes/overview.html#fixing-instability-with-pole-placement"
  },"98": {
    "doc": "Open loop vs closed loop control",
    "title": "An Ideal Controller",
    "content": ". | design for stability | compensate for uncertainty | reject diturbance | attenduate noise | . ",
    "url": "/notes/overview.html#an-ideal-controller",
    
    "relUrl": "/notes/overview.html#an-ideal-controller"
  },"99": {
    "doc": "Open loop vs closed loop control",
    "title": "Why is Open Loop Transfer Functions Important",
    "content": ". | Closed-loop stability depends on open-loop behavior . | The closed-loop characteristic equation is: \\(1+L(s)=0\\) where \\(L(s)\\) is the open-loop transfer function. | All the closed-loop poles (which determine stability) come from this equation. | If \\(L(s)\\) has certain properties (like unstable poles or bad phase margins), the closed loop can become unstable. | . | Open Loop Transfer Functions reveal robustness by Sensitivity and Complementary Sensitivity . | The closer the Open Loop Transfer Function L gets to -I, the bigger Sensitivity gets, and the less stable the system gets | . | . ",
    "url": "/notes/overview.html#why-is-open-loop-transfer-functions-important",
    
    "relUrl": "/notes/overview.html#why-is-open-loop-transfer-functions-important"
  },"100": {
    "doc": "Open loop vs closed loop control",
    "title": "Domains",
    "content": ". ",
    "url": "/notes/overview.html#domains",
    
    "relUrl": "/notes/overview.html#domains"
  },"101": {
    "doc": "Open loop vs closed loop control",
    "title": "Open loop vs closed loop control",
    "content": " ",
    "url": "/notes/overview.html",
    
    "relUrl": "/notes/overview.html"
  },"102": {
    "doc": "Performance Specifications",
    "title": "Performance Specifications",
    "content": " ",
    "url": "/notes/performance_specs.html",
    
    "relUrl": "/notes/performance_specs.html"
  },"103": {
    "doc": "Performance Specifications",
    "title": "Control System Specs ‚Üí Design Actions Cheat Sheet",
    "content": "| Requirement / Spec | What It Means | Design Adjustments | . | Steady-State Error (Ess) | Final tracking error to step/ramp inputs | Increase system type (add integrator), adjust Ki in PID, or use lag compensator | . | Rise Time (tr) | Speed to reach near-final value | Increase system bandwidth, add lead compensator, increase Kp | . | Overshoot (Mp) | How much output exceeds target | Increase damping ratio (reduce Kp, increase Kd), use lead-lag tuning | . | Settling Time (ts) | Time to stay within ¬±X% band | Increase natural frequency, increase damping via derivative gain or lead compensation | . | Damping Ratio (Œ∂) | Oscillation level in transient | Adjust Kd or use lead to increase phase margin | . | Gain Margin (GM) | How much gain can increase before instability | Add phase lead, reduce open-loop gain | . | Phase Margin (PM) | Extra phase lag before instability | Add phase lead, adjust crossover frequency | . | Bandwidth | Frequency range of good tracking | Increase gain/lead for faster response, but watch noise | . | Disturbance Rejection | Suppress low/high frequency disturbances | Add integrator for low-freq rejection, notch filters for specific frequencies | . | Noise Sensitivity | Avoid amplifying sensor noise | Reduce bandwidth, use low-pass filter on derivative term | . | Control Effort Limit | Actuator magnitude/rate constraints | Add rate limiter, reduce aggressive gains, use anti-windup | . ",
    "url": "/notes/performance_specs.html#control-system-specs--design-actions-cheat-sheet",
    
    "relUrl": "/notes/performance_specs.html#control-system-specs--design-actions-cheat-sheet"
  },"104": {
    "doc": "Performance Specifications",
    "title": "Steady-State Error (SSE)",
    "content": ". | Definition: \\(e_{ss} = \\lim_{t\\to\\infty} e(t)\\) | Using FVT: \\(e_{ss} = \\lim_{s\\to 0} s\\,E(s)\\) | System type &amp; error constants . | Type 0 ‚Üí \\(K_p\\), step error finite; ramp error ‚àû | Type 1 ‚Üí \\(K_v\\), step error 0; ramp error finite; parabolic ‚àû | Type 2 ‚Üí \\(K_a\\), step &amp; ramp 0; parabolic finite | . | Typical specs: ‚ÄúSSE ‚â§ 2% for step,‚Äù etc. | . Steady-State Error (Unity Feedback, Stable CL, FVT valid) | System Type | Step InputR(s)=1/s | Ramp InputR(s)=1/s2 | Parabolic InputR(s)=1/s3 | . | Type 0 | ess = 1 / (1 + Kp)finite | ess = &infin; | ess = &infin; | . | Type 1 | ess = 0 | ess = 1 / Kvfinite | ess = &infin; | . | Type 2 | ess = 0 | ess = 0 | ess = 1 / Kafinite | . Definitions (with L(s) = C(s)G(s), the open-loop transfer function): Kp = lim_{s‚Üí0} L(s), Kv = lim_{s‚Üí0} s¬∑L(s), Ka = lim_{s‚Üí0} s¬≤¬∑L(s). Assumptions &amp; Notes . | Unity feedback structure and stable closed-loop (no RHP poles, FVT valid). | ‚ÄúType‚Äù = number of pure integrators in L(s) (i.e., number of poles at the origin). | FVT form for error: e_ss = lim_{s‚Üí0} [ s¬∑E(s) ] = lim_{s‚Üí0} [ s¬∑R(s)/(1+L(s)) ]. | . Final Value Theorem (FVT) . | Statement: If all poles of \\(sX(s)\\) are in the open left half-plane (no RHP poles, no repeated poles on the imaginary axis), then \\(\\lim_{t\\to\\infty} x(t) = \\lim_{s\\to 0} s\\,X(s).\\) | Common pitfalls: Undamped oscillators, marginally stable poles, or non-proper forms invalidate FVT. | Using FVT to get SSE: \\(e_{ss} = \\lim_{s\\to 0} s\\,E(s) = \\lim_{s\\to 0} s\\left[\\frac{R(s)}{1+L(s)}\\right]\\) for unity feedback, with \\(L(s)=G(s)C(s)\\). \\(R(s)\\) = Input to the control system (reference) in laplace domain . \\(C(s)\\) = Controller transfer function . \\(G(s)\\) = Plant transfer function . \\(L(s)=C(s)G(s)\\) = Open-loop transfer function . | . ",
    "url": "/notes/performance_specs.html#steady-state-error-sse",
    
    "relUrl": "/notes/performance_specs.html#steady-state-error-sse"
  },"105": {
    "doc": "PID Control",
    "title": "PID Control",
    "content": "This page only covers continuous-time PID control. For more advanced topics on discrete PID, visit Discrete Time Control page for more details. PID by itself is a linear controller. Gain scheduling, anti-windup schemes, derivative filtering, gain scheduling can make it non-linear. ",
    "url": "/notes/pid.html",
    
    "relUrl": "/notes/pid.html"
  },"106": {
    "doc": "PID Control",
    "title": "Limitations of PID",
    "content": ". | PID in general do not provide optimal control. | PID controllers have difficulties in the presence of non-linearities. | PID may be the best controller for an observer that has no model of the process. However, better performance can be obtained by modeling the actor of the process. | . ",
    "url": "/notes/pid.html#limitations-of-pid",
    
    "relUrl": "/notes/pid.html#limitations-of-pid"
  },"107": {
    "doc": "PID Control",
    "title": "How to Improve a PID",
    "content": ". | The most significant improvement is to incorporate feed-forward control and use PID only to control error. | PID can be coupled with gain scheduling, improving measurement (higher sampling rate for instance). | The derivative term can be coupled with low-pass filtering. | Cascading multiple PID controllers. | . ",
    "url": "/notes/pid.html#how-to-improve-a-pid",
    
    "relUrl": "/notes/pid.html#how-to-improve-a-pid"
  },"108": {
    "doc": "PID Control",
    "title": "Which controller to use?",
    "content": "\\(\\begin{array}{c|c|c|c} Example &amp; System Order &amp; Controller &amp; Reasoning\\\\ \\hline \\text{Controlling mass position using force} &amp; 2 &amp; \\text{PD or PID} &amp; \\text{Typically needs damping like mass-spring damper, otherwise will oscillate} \\\\ \\text{Controlling V across C using current} &amp; 1 &amp; \\text{P or PI} &amp; \\text{Not much danger of over-shoot or oscillation} \\\\ \\text{Controlling I across R using voltage} &amp; 0 &amp; \\text{P or PI} &amp; \\text{Not much danger, direct mapping} \\end{array}\\) . Note System order denotes how many ‚Äòintegrations‚Äô away your control input is from the output. For instance, controlling position with force would be a second-order system. ",
    "url": "/notes/pid.html#which-controller-to-use",
    
    "relUrl": "/notes/pid.html#which-controller-to-use"
  },"109": {
    "doc": "PID Control",
    "title": "PI vs PD vs PID",
    "content": "The derivative controller is highly sensitive to noise and may throw the system into instability. PI controller . PI controller reduces both rise time and the steady-state errors of the system. The integral term introduces phase lag, which may slow down response time. PD controller . A PD controller reduces transients like rise time, overshoot, and oscillations in the output. D controller cannot exist on its own since itself doesn‚Äôt stabilize the system but amplifies noise. | Gain | Too Low | Too High | Why | . | Proportional (K_p) | - Sluggish response- Large steady-state error (SSE)- Poor disturbance rejection | - Large overshoot- Increased oscillations or ringing- Reduced phase margin ‚Üí possible instability- High sensitivity to noise and disturbances | (K_p) increases loop gain and bandwidth, improving speed but reducing stability margins and increasing oscillatory behavior. | . | Integral (K_i) | - SSE remains- Poor low-frequency disturbance rejection- System may never reach setpoint | - Overshoot and oscillations from windup- Long settling time after overshoot- Possible instability even for stable P-only systems | (K_i) accumulates error to remove SSE, but excessive accumulation (windup) drives large corrective action, overshooting the setpoint before unwinding. | . | Derivative (K_d) | - Underdamped response if damping from D is needed- More overshoot than necessary- Poor transient shaping | - High-frequency noise amplification- Chattering or actuator vibration- Possible instability if noise excites system dynamics | (K_d) acts on error rate, improving damping. Too much magnifies sensor noise, creating large, rapid control signals that stress actuators and excite high-frequency dynamics. | . ",
    "url": "/notes/pid.html#pi-vs-pd-vs-pid",
    
    "relUrl": "/notes/pid.html#pi-vs-pd-vs-pid"
  },"110": {
    "doc": "PID Control",
    "title": "Strategies for Tuning a PID Controller",
    "content": ". Diagram Walkthrough . | Model representation | . | Run input sequence . | Observe step response for Cohen-Coon | . | Heuristic Methods: System model not required, only need to measure certain traits such as process gain, time constant, and dead time. | Cohen-Coon | Ziegler‚ÄìNichols (needs to be careful on hardware, due to oscillatory behavior) | . | System Identification. | Measure step-response of system. | Tweak your model coefficients so step responses match. | Model needs to be defined beforehand. | . | Tuning method with Model . | Manual tuning . | Pole placement | Loop shaping | Heuristic Methods (make model oscillatory NOT hardware) | . | Auto tuning | . | . Manual PID Tuning Strategy . | Start with: | . \\[K_P &gt; 0, \\quad K_I = 0, \\quad K_D = 0\\] . | Increase \\(K_P\\) until: . | The system starts responding to setpoint changes. | It begins to oscillate consistently without settling. | . This means it‚Äôs reached the edge of stability. | Back off \\(K_P\\) by ~10‚Äì20% to get a stable (but responsive) system. | Increase \\(K_D\\) to: . | Dampen the oscillations. | Improve settling time and reduce overshoot. | . | Increase \\(K_I\\) slowly to: . | Eliminate steady-state error (e.g. small drift from setpoint). | Watch for overshoot or oscillation due to integral windup. | . | . ",
    "url": "/notes/pid.html#strategies-for-tuning-a-pid-controller",
    
    "relUrl": "/notes/pid.html#strategies-for-tuning-a-pid-controller"
  },"111": {
    "doc": "PID Control",
    "title": "üß™ Ziegler‚ÄìNichols Method (Ultimate Gain Method)",
    "content": "This is a classical tuning rule. It gives you a starting point for \\(K_P,\\ K_I,\\ \\text{and}\\ K_D\\) based on when the system first starts oscillating. üîß Steps: . | Set: \\(K_I = 0,\\quad K_D = 0\\) . | Increase \\(K_P\\) until the system output shows sustained oscillations (constant amplitude). | That value of \\(K_P\\) is called the ultimate gain, denoted: \\(K_u\\) | . | Measure the oscillation period ‚Äî the time between peaks ‚Äî and call it: \\(T_u\\) . | . üìê Use these tables to compute gains: . | Controller | \\(K_P\\) | \\(K_I\\) | \\(K_D\\) | . | P | \\(0.5K_u\\) | ‚Äì | ‚Äì | . | PI | \\(0.45K_u\\) | \\(1.2K_u / T_u\\) | ‚Äì | . | PID | \\(0.6K_u\\) | \\(2K_u / T_u\\) | \\(K_u T_u / 8\\) | . | Control Type | \\(K_p\\) | \\(T_i\\) | \\(T_d\\) | \\(K_i\\) | \\(K_d\\) | . | P | \\(0.5K_u\\) | ‚Äì | ‚Äì | ‚Äì | ‚Äì | . | PI | \\(0.45K_u\\) | \\(0.8\\overline{3}T_u\\) | ‚Äì | \\(0.54K_u / T_u\\) | ‚Äì | . | PD | \\(0.8K_u\\) | ‚Äì | \\(0.125T_u\\) | ‚Äì | \\(0.10K_u T_u\\) | . | Classic PID | \\(0.6K_u\\) | \\(0.5T_u\\) | \\(0.125T_u\\) | \\(1.2K_u / T_u\\) | \\(0.075K_u T_u\\) | . | Pessen Integral Rule | \\(0.7K_u\\) | \\(0.4T_u\\) | \\(0.15T_u\\) | \\(1.75K_u / T_u\\) | \\(0.105K_u T_u\\) | . | Some Overshoot | \\(0.3\\overline{3}K_u\\) | \\(0.50T_u\\) | \\(0.3\\overline{3}T_u\\) | \\(0.6\\overline{6}K_u / T_u\\) | \\(0.1\\overline{1}K_u T_u\\) | . | No Overshoot | \\(0.20K_u\\) | \\(0.50T_u\\) | \\(0.3\\overline{3}T_u\\) | \\(0.40K_u / T_u\\) | \\(0.06\\overline{6}K_u T_u\\) | . ‚ö†Ô∏è Notes for Drone Applications . | Ziegler‚ÄìNichols gives aggressive tuning, often with overshoot. | For drones, it‚Äôs safer to: . | Start with rate control loops (angular velocity). | Then move to attitude control (roll, pitch, yaw). | . | . ",
    "url": "/notes/pid.html#-zieglernichols-method-ultimate-gain-method",
    
    "relUrl": "/notes/pid.html#-zieglernichols-method-ultimate-gain-method"
  },"112": {
    "doc": "PID Control",
    "title": "Integral Windup",
    "content": "Error builds up even though actuator saturates. Takes time for negative error to be reflected in the controller. Anti-Windup . Most anti-windup schemes prevent the integral from accumulating error past a threshold . | Clamping: two checks (if both true, shut off integration) . | Output is saturating (clamp the output of the PID (this needs to be conservative), if the output before and after the clamp are the same, then the actuator is beginning to get saturated.) | Input and output have the same sign | . | Block calculation | Observer approach | . ",
    "url": "/notes/pid.html#integral-windup",
    
    "relUrl": "/notes/pid.html#integral-windup"
  },"113": {
    "doc": "PID Control",
    "title": "Derivative Control",
    "content": "Derivative control ‚Äúpredicts the future‚Äù in contrast to integral control - a decrease in error gives a decrease in control input. Noise amplifies derivative control output. Derivative Control Example . Altitude Control for Quadcopter: Desired altitude 50m, as drone shoots up, error term decreases (negative derivative) -&gt; negative value from derivative term, slows motors down, reduces overshoot. ",
    "url": "/notes/pid.html#derivative-control",
    
    "relUrl": "/notes/pid.html#derivative-control"
  },"114": {
    "doc": "PID Control",
    "title": "How to derive a model",
    "content": "First principles . This method also works if one knows the individual components of the system. | Newtonian Mechanics | Lagrangian Mechanics | . System ID . If the model is too complicated, system ID can work (black box method). No need to know the details of the system. ",
    "url": "/notes/pid.html#how-to-derive-a-model",
    
    "relUrl": "/notes/pid.html#how-to-derive-a-model"
  },"115": {
    "doc": "PID Control",
    "title": "PID Pole Placement (LQG) and Loop Shaping (Robust Control)",
    "content": "PID Transfer Function . \\(C(s) = K_p + \\frac{K_i}{s} + K_d s\\) . How does PID affect Loop Shaping (Bode Plot): . 1. Proportional term (\\(K_p\\)) . | Simply scales the magnitude of the open-loop transfer function across all frequencies by \\(K_p\\) (shifts the Bode magnitude plot up or down). | No slope change, no phase lead/lag (phase stays the same as the plant‚Äôs at each frequency). | . 2. Integral term (\\(\\frac{K_i}{s}\\)) . | Adds a pole at \\(s=0\\) and a zero at \\(s=-K_i/K_p\\) (if expressed in standard form for PI control). | In the Bode plot: increases low-frequency gain slope by +20 dB/dec below the zero, giving better low-frequency tracking and disturbance rejection. | Phase: introduces ‚Äì90¬∞ lag below the zero frequency (eventually reduced to 0¬∞ after the zero). | . 3. Derivative term (\\(K_d s\\)) . | Adds a zero at the origin and a pole at infinity (in practice, implemented with a high-frequency roll-off to avoid noise). | In the Bode plot: increases high-frequency gain slope by +20 dB/dec above the zero‚Äôs frequency, giving phase lead and faster response. | Phase: can give up to +90¬∞ lead around its zero. | . Putting them together in loop shaping: . | Integral boosts the low-frequency magnitude to push the gain crossover lower and improve steady-state accuracy. | Derivative boosts magnitude at mid-frequencies to increase phase margin, which can stabilize a plant with low natural phase margin. | Proportional shifts the entire magnitude plot up or down to meet your crossover frequency and gain margin targets. | . ",
    "url": "/notes/pid.html#pid-pole-placement-lqg-and-loop-shaping-robust-control",
    
    "relUrl": "/notes/pid.html#pid-pole-placement-lqg-and-loop-shaping-robust-control"
  },"116": {
    "doc": "PID Control",
    "title": "PID Effect on Pole Placement",
    "content": "1Ô∏è‚É£ Starting point ‚Äî closed-loop poles come from \\(1 + L(s) = 0\\) . For unity feedback: . \\[T(s) = \\frac{C(s) G(s)}{1 + C(s) G(s)}\\] The closed-loop poles are the roots of: . \\[1 + C(s) G(s) = 0\\] Adding a PID means replacing \\(C(s)\\) with: . \\[C(s) = K_p + \\frac{K_i}{s} + K_d s\\] That changes the polynomial \\(1 + C(s) G(s) = 0\\), which changes the pole locations. 2Ô∏è‚É£ How each term influences pole placement . (a) Proportional \\(K_p\\) . | Multiplies the plant‚Äôs transfer function by a constant. | Effect: Moves the closed-loop poles along the root locus without changing its shape. | Higher \\(K_p\\) ‚Üí poles move toward/into the left-half plane faster (increasing speed) but can reduce stability margin. | . (b) Integral \\(\\frac{K_i}{s}\\) . | Adds a pole at the origin to the open-loop transfer function. | This changes the root locus shape, not just shifts along it. | Forces the steady-state error for step inputs to zero by making the closed-loop a Type 1 system (or higher). | Because it adds a pole, it can also slow down the system and reduce damping unless compensated. | . (c) Derivative \\(K_d s\\) . | Adds a zero to the open-loop transfer function. | Zeros bend the root locus toward themselves, which can move dominant poles to locations with higher damping ratio. | Used to improve transient response (overshoot, settling time) by pulling poles into a ‚Äúnicer‚Äù part of the complex plane. | . 3Ô∏è‚É£ Big picture: PID in pole placement terms . | P: Changes gain ‚Üí moves poles along an existing root-locus path. | I: Adds a pole at origin ‚Üí changes the shape of the root locus, introduces the integrator effect. | D: Adds a zero ‚Üí bends the root locus toward more desirable damping. | . The net effect is that PID changes both: . | The geometry of the root locus (via added poles/zeros) | The position along that locus (via gain tuning) | . ",
    "url": "/notes/pid.html#pid-effect-on-pole-placement",
    
    "relUrl": "/notes/pid.html#pid-effect-on-pole-placement"
  },"117": {
    "doc": "PID Control",
    "title": "Gain Scheduling - Control Systems in Practice",
    "content": "Motivation . Linear controllers may only work well under certain operating conditions but not all. Linear Parameter Varying systems: A fixed linear transfer function but different parameters under different operating conditions. How to deal with LPV systems? . | Build nonlinear controller. | Build linear robust controller. Drop in performance and may not even be possible. | Limit operations. | Gain scheduling. | . Visualization . Implementation . Steps . | Linearize plant at each design operating condition. (linear controller for linear plant) . | Find a critical point in each of the regions that represents the whole area well | Linearize plant at the point | . | Tune gains at each design point . | Performance (or even stability in some cases) is only guaranteed at the design points | Either use a single gain for the entire area or interpolate gains between two points | Make controller more robust or add more design points | . | Choose the gain scheduling architecture . | A switch system. However, it may produce some unintended transients at the switch condition | See next section for more details | . | Assess the control performance . | Often simulated | All critical transitions and corner cases should be covered | . | . Preventing drastic changes . Scenario: At the boundary points of the gain areas, errors don‚Äôt change much, but a discrete switch causes controller gain to change -&gt; causing erratic behavior. Methods . | Transient-free switch . | Gain curve (2D) and Gain surface (3D) . | . ",
    "url": "/notes/pid.html#gain-scheduling---control-systems-in-practice",
    
    "relUrl": "/notes/pid.html#gain-scheduling---control-systems-in-practice"
  },"118": {
    "doc": "PID Control",
    "title": "Important Advanced PID concepts for Further Study",
    "content": "Cascade Loops . Why multiple loops? . | Inner loops can be tuned to respond quickly to local disturbances, the outer loop can be tuned more conservatively to reject sensor noise and increase stability | Cascade approach makes it easier to isolate the problem | Multiple groups can work on separate parts. | The motor you buy has a built-in controller | . | . How to Tune Cascade loops . | Case 1: Inner loop speed¬†¬ª outer loop speed . | Can be tuned separately. Assume the other loop is not present and tune like normal | . | Case 2: Inner loop speed \\(\\approx\\) Outer loop speed . | Tune inner loop with a guess | Tune outer loop | Iterate | . | . Discrete PID . There are three major characteristics of a digital system: 1. Sample Time 2. Quantization 3. Transport Delay . Please check out discrete time control page for more details on discrete PID controller . ",
    "url": "/notes/pid.html#important-advanced-pid-concepts-for-further-study",
    
    "relUrl": "/notes/pid.html#important-advanced-pid-concepts-for-further-study"
  },"119": {
    "doc": "Pole Placement",
    "title": "Pole Placement",
    "content": " ",
    "url": "/notes/pole_placement.html",
    
    "relUrl": "/notes/pole_placement.html"
  },"120": {
    "doc": "Pole Placement",
    "title": "Linear system",
    "content": "For the controllable linear system, \\(\\dot{x} = Ax+Bu, u=-Kx, \\dot{x}=(A-BK)x\\), . there‚Äôs a trade off between convergence rate (eigenvalues or poles) and system jerkiness, ie, more negative real parts would lead to faster convergence to stability but sacrifice system response smoothness. Linear Quadratic Regulator (LQR) can be used to find optimal point. Poles to the far left of the complex plane: . Pro: . | Faster Response | Increased stability margin | . Cons: . | Control effort becomes large. Actuators may saturate. | Sensitivity to Noise and model uncretainty. High gain feedback amplified measurement noise and unmodeled dynamics | Numerical instability | Reduced Robustness | . ",
    "url": "/notes/pole_placement.html#linear-system",
    
    "relUrl": "/notes/pole_placement.html#linear-system"
  },"121": {
    "doc": "Pole Placement",
    "title": "Linear Quadratic Regulator",
    "content": "Formulation . Cost function \\(J=\\int_{0}^{\\infty}(x^TQx + u^TRu)dt\\), where Q is positive semidefinite and x and u are dependet on t. There are two components of the cost: . | first term penalizes difference between desired state and actual state, which accelerates convergence. | second term penalizes bigger u - for instance, gas may be expensive and the cost cannot be exorbitant. The term linear refers to \\(u=-Kx\\), which is a linear controller; Quadratic refers to the Cost function; Regulator means this stabilizes the system. Result . LQR gives u=-Kx specifically the K matrix that yields the best strategy. | . ",
    "url": "/notes/pole_placement.html#linear-quadratic-regulator",
    
    "relUrl": "/notes/pole_placement.html#linear-quadratic-regulator"
  },"122": {
    "doc": "Pole Placement",
    "title": "Linear Quadratic Estimator",
    "content": "The Kalman filter is an example of an LQE. More details are in State Estimation page. ",
    "url": "/notes/pole_placement.html#linear-quadratic-estimator",
    
    "relUrl": "/notes/pole_placement.html#linear-quadratic-estimator"
  },"123": {
    "doc": "Robust Control",
    "title": "Robust Control and Loop Shaping",
    "content": "Robust control is not one controller like PID but rather a desing method that allows us to tune PID gains or other controllers so the actual controller is robust. ",
    "url": "/notes/robust_control.html#robust-control-and-loop-shaping",
    
    "relUrl": "/notes/robust_control.html#robust-control-and-loop-shaping"
  },"124": {
    "doc": "Robust Control",
    "title": "What is Robustness?",
    "content": "A robust system is one capable of meeting requirements (stability or performance measures) even in the presence of model uncertainty and/or disturbance uncertainty. ",
    "url": "/notes/robust_control.html#what-is-robustness",
    
    "relUrl": "/notes/robust_control.html#what-is-robustness"
  },"125": {
    "doc": "Robust Control",
    "title": "Motivation and Background",
    "content": "A paper by John Doyle proved that there is no guarantee on robustness of LQG scheme. This discovery pushed the industry towards robust control. We need to delve into Laplace domain and determine Robustness of a system. Laplace Transform domain gives us insights into the performance, sensitivity, and robustness characteristics. ",
    "url": "/notes/robust_control.html#motivation-and-background",
    
    "relUrl": "/notes/robust_control.html#motivation-and-background"
  },"126": {
    "doc": "Robust Control",
    "title": "A Quick Note about this Section",
    "content": "All the material on SISO systems below only pertains to variations at the input. ",
    "url": "/notes/robust_control.html#a-quick-note-about-this-section",
    
    "relUrl": "/notes/robust_control.html#a-quick-note-about-this-section"
  },"127": {
    "doc": "Robust Control",
    "title": "Why use Disk Margin?",
    "content": ". | Even though increasing delay or increasing gain individually (reducing GM and PM respectively) may not cause the system to be unstable, adding a mix of the two can unstabilize the system. The disk margin therefore needs to be considered. To anaylze the effect of adding phase and gain, use Nyquist Plot. | Disk margin can be used on MIMO. | . ",
    "url": "/notes/robust_control.html#why-use-disk-margin",
    
    "relUrl": "/notes/robust_control.html#why-use-disk-margin"
  },"128": {
    "doc": "Robust Control",
    "title": "Disk Margin",
    "content": ". The disk reads ‚ÄúGiven \\(e=0.0\\), the maximum disk margin is 0.56‚Äù . Parameters of the disk . The disk must be fit entirely in the stable region and includes the nominal point \\(f =1 + 0i\\) . | Skew factor \\(e\\). how far off the center of the disk is to the nominal point. | \\(\\alpha\\) measures the size of the disk. It represents the size of the disk given a certain \\(e\\) such that the disk is entirely in the stable region. | . Disk Placement . You can choose where the disk is: . | If you think real system gain is bigger than model gain, use a bigger \\(e\\) . | If unsure, choose \\(e = 0.0\\) | . | Disk margin may not be conservative even if it may only covers a small area of stability zone. | in this case, while gain margin is bigger, at those bigger gain values, not much wiggle room for phase -&gt; not optimal | . | May need to check all three margins to ensure accurate representation of the stability. | Some systems are robust to pure phase or gain variations but not a mix of the two | . | . ",
    "url": "/notes/robust_control.html#disk-margin",
    
    "relUrl": "/notes/robust_control.html#disk-margin"
  },"129": {
    "doc": "Robust Control",
    "title": "Disk Margin for MIMO",
    "content": "Multi-loop Input Disk Margin (Input TO PLANT Only) . The Multi-loop Input disk margin is the largest disk such that any \\(n\\) independent variations within the disk were applied to the \\(n\\) plant inputs, the loop would be stable. Multi-loop Output Disk Margin (Output Only) . The Multi-loop Output disk margin is the . Multi-loop Input/Output Disk Margin . MIMO Disk Margin Example . A simple MIMO controller can be designed by taking the inverse of the plant transfer functions matrix \\(G(s)\\). We can then use loop shaping and mulitply the controller with \\(\\frac{1}{s}\\). In this case the system behaves like an integrator. Input: . | Loop-at-a-time input disk margins (varying input one at a time): . | Infinite Gain margins and large phase margins | . | MLIDM is very similar to Loop-at-a-time: . | Infinite Gain margins and large phase margins | This is because the channels are decoupled by the inverse! | . | . Output: Since we mulitplied G(s) by its inverse, this practically decoupled the channels. | Loop-at-a-time output disk margin (varying output one at a time) | MLODM also yields | . MIMO (Multi-loop concurrent input/output disk margins): . | Very little Gain Margin and Phase Margin | . Reasoning: Inverting the plant is not desirable since this is assuming perfectly cancellation between the pole and zero. If there‚Äôs any perturbation, the design falls apart. ",
    "url": "/notes/robust_control.html#disk-margin-for-mimo",
    
    "relUrl": "/notes/robust_control.html#disk-margin-for-mimo"
  },"130": {
    "doc": "Robust Control",
    "title": "System Parameter Uncertainty",
    "content": ". For a dual-cart system, there may be uncertainties in model parameters such as spring constant K and mass m. Undesirable: Monte Carlo . Generate random models within a threashold of the model parameters and check stability. Monte Carlo may claim false positives. Matlab robstab . ",
    "url": "/notes/robust_control.html#system-parameter-uncertainty",
    
    "relUrl": "/notes/robust_control.html#system-parameter-uncertainty"
  },"131": {
    "doc": "Robust Control",
    "title": "This approach analytically solves for the cases where the system becomes unstable",
    "content": " ",
    "url": "/notes/robust_control.html#this-approach-analytically-solves-for-the-cases-where-the-system-becomes-unstable",
    
    "relUrl": "/notes/robust_control.html#this-approach-analytically-solves-for-the-cases-where-the-system-becomes-unstable"
  },"132": {
    "doc": "Robust Control",
    "title": "Three Equivalent Representations of Linear Systems",
    "content": ". | State space representation \\(\\dot{x}=Ax+Bu \\\\ y=Cx\\) | Transfer functions \\(G(s)=C(sI-A)^{-1}B\\) | Impulse response time domain \\(y(t)=\\int_{0}^{t}h(t-\\tau)u(\\tau)d\\tau\\) This is a convolution between impulse response and control input | . Note there are different usages for each of the three representations. | If physics can be represented, State space representation can be very useful. | Transfer functions can be useful for investigating robustness and performance | . ",
    "url": "/notes/robust_control.html#three-equivalent-representations-of-linear-systems",
    
    "relUrl": "/notes/robust_control.html#three-equivalent-representations-of-linear-systems"
  },"133": {
    "doc": "Robust Control",
    "title": "Deriving Sensitivity and Complementary Sensitivity with Loop Transfer Function",
    "content": ". where d is disturbance, n is measurement noise, r is reference setpoint, P is the system transfer function, and K is the controller transfer function. \\[L = PK\\] Note K is applied first to the error before P. \\[I*y = P_{d}*d+ PK(r-y-n), \\text{where} (r-y-n) = \\epsilon\\] \\[(I+Pk)*y = PKr + P_{d}*d - PKn\\] \\[y = (I+P*K)^{-1} * PKr + (I+PK)^{-1}P_{d}d - (I+PK)^{-1}PKn\\] \\(\\text{Therefore, } (I+PK)^{-1}PK \\text{ is called complimentary sensitivity matrix, and } (I+(Pk))^{-1} \\text{ is the sensitivity matrix}\\) . | first term of y tracks trajectory | second term of y rejects disturbance | third term of y attenuates noise | . ",
    "url": "/notes/robust_control.html#deriving-sensitivity-and-complementary-sensitivity-with-loop-transfer-function",
    
    "relUrl": "/notes/robust_control.html#deriving-sensitivity-and-complementary-sensitivity-with-loop-transfer-function"
  },"134": {
    "doc": "Robust Control",
    "title": "Sensitivity and Complementary Sensitivity Functions",
    "content": "In a standard negative feedback loop: . | Plant: \\(G(s)\\) | Controller: \\(K(s)\\) | Loop transfer function: \\(L(s) = K(s)G(s)\\) | . 1. Sensitivity Function \\(S(s)\\) . \\[S(s) = \\frac{1}{1 + L(s)} = \\frac{1}{1 + K(s)G(s)}\\] . | Measures the system‚Äôs sensitivity to disturbances and model uncertainty. | A smaller \\(|S(j\\omega)|\\text{ means better disturbance rejection at frequency }\\omega\\). | . 2. Complementary Sensitivity Function \\(T(s)\\) . \\[T(s) = \\frac{L(s)}{1 + L(s)} = \\frac{K(s)G(s)}{1 + K(s)G(s)}\\] . | Measures the system‚Äôs response to the reference input and its sensitivity to measurement noise. | A larger \\(|T(j\\omega)|\\) at low frequencies means better reference tracking. | . 3. Transfer Functions Bode Plots . Error Term \\(\\mathcal{E} = r - y_{m} = S*r - S*P_{d}*d + T*n\\) where . | \\(n\\) is measurement noise | \\(P_{d}\\) is disturbance Transfer Function and d is disturbance. \\((\\text{L loop output} + P_{d}*d=y)\\) | \\(r\\) is reference setpoint | \\(S\\) is Sensitivity and \\(T\\) is Complementary Sensitivity | . Why does the Bode plot look like that? . | S needs to be small in low frequencies to minimize error \\(\\mathcal{E}\\) (first term in \\(\\mathcal{E}\\) formula), since a realistic \\(r\\) would be low in frequency for system to follow. | Reference Tracking and disturbance rejection are typically low frequency phenomemon. | T needs to be small in maganitude for high frequencies, since noise \\(n\\) is generally high in frequency. | \\(\\omega_ {c}\\) denotes the crossover frequency, being the frequency at which Sensitivity starts to increase and Complementary Sensitivity begins to decrease. | \\(\\omega_ {c}\\) can be tuned to be where the user thinks noise begin to overwhelm the system. | Peaks or bumps in Sensitivty transfer function is undesirable and needs to be attenuated | . 4. Relationship . \\[S(s) + T(s) = 1\\] . MIMO Case (Matrix Form) . Let: . | \\(G(s) \\in \\mathbb{R}^{p \\times m}\\) be the plant | \\(K(s) \\in \\mathbb{R}^{m \\times p}\\) be the controller | \\[L(s) = G(s)K(s)\\] | . Then: . \\(S(s) = (I + L(s))^{-1}\\) \\(T(s) = L(s)(I + L(s))^{-1}\\) . These satisfy: . \\[S(s) + T(s) = I\\] . Summary . | Function | Formula | Meaning | . | \\(S(s)\\) | \\(\\frac{1}{1 + K(s)G(s)}\\) or \\((I + G(s)K(s))^{-1}\\) | Sensitivity to disturbances | . | \\(T(s)\\) | \\(\\frac{K(s)G(s)}{1 + K(s)G(s)}\\) or \\(G(s)K(s)(I + G(s)K(s))^{-1}\\) | Response to reference / noise sensitivity | . | Relation | \\(S + T = 1\\) or \\(S + T = I\\) | Always holds | . ",
    "url": "/notes/robust_control.html#sensitivity-and-complementary-sensitivity-functions",
    
    "relUrl": "/notes/robust_control.html#sensitivity-and-complementary-sensitivity-functions"
  },"135": {
    "doc": "Robust Control",
    "title": "Loop Shaping",
    "content": ". | The Bode plot of the Loop Transfer Function looks like an Integrator . | high gain at low frequencies for good reference tracking and noise rejection (S needs to be small so L needs to be big ) | low gain at high frequencies to attenuate noise | bode plot can be shifted left or right by multiplying transfer function by \\(\\omega_{s}/s\\) | . | Loop shaping is a collection of several different design methods based on the idea of choosing a compensator that gives a loop transfer function with a desired shape. | One possibility is to start with the loop transfer function of the process and modify it by changing the gain and adding poles and zeros to the controller until the desired shape is obtained. | . If you have a model for the system and a desired Loop Transfer Function, MATLAB can tune K, the controller transfer function to robustify control system. No LQG needed. Non-Robustness for Loop Shaping . The peaks in Sensitivity graph is undesirable since the larger the peak, the closer the controller system gets to instability (-1 point on the Nyquist plot). where \\(max|s|=1/m\\) . Therefore a larger peak in sensitivity S correspond to a closer distance to instability. The actual system dynamics can rotate the curve (Phase) or shift it left to make the system unstable. Cone of Uncertainty . This takes into account of model uncertainty in P. Causes of Non-Robustness and Unstability . | model uncertainty. The real system gain is smaller or bigger than the model | Time delays. | Right Half Plane (RHP) zeros of P (the system transfer function) | . Important Note: Time delay and RHP zeros of P give a fundamental limit on how small \\(max(|S|)\\) can be! To satisfy these hard rules set by Time delay and RHP zeros, one needs to shift \\(\\omega_{c}\\) (the crossover frequency) to the left. This means the systems can only track low frequency references and reject lower frequency disturbances. Recall: a RHP zero would cause the system to go in the wrong direction before converging. (This behavior is similar to a time delay.) . A RHP zero introduces Non-minimum Phase and would cause the system to go in the wrong direction before converging. Example: 1. Aircraft gaining altitude. 2. parallel park. ",
    "url": "/notes/robust_control.html#loop-shaping",
    
    "relUrl": "/notes/robust_control.html#loop-shaping"
  },"136": {
    "doc": "Robust Control",
    "title": "\\(H_\\infty\\)",
    "content": " ",
    "url": "/notes/robust_control.html#h_infty",
    
    "relUrl": "/notes/robust_control.html#h_infty"
  },"137": {
    "doc": "Robust Control",
    "title": "\\(H_\\infty\\) Synthesis",
    "content": "\\(H_\\infty\\) methods are used to synthesize controllers to achieve stabilization with guaranteed performance. To use such methods, one needs to express the control problem as a mathematical optimization problem and then finds the controller that solves this optimization. The resulting controller is only optimal with respect to the prescribed cost function and does not necessarily represent the best controller in terms of the usual performance measures used to evaluate controllers such as settling time, energy expended, etc. Also, non-linear constraints such as saturation are generally not well-handled. \\(H_\\infty\\) techniques can be used to minimize the closed loop impact of a perturbation. May not be robust for variations in system model. Advantages . Advantages: . | \\(H_\\infty\\) is readily applicable to problems with multivariate systems with cross-coupling between channels. | . Disadvantages . | Complex math | A good model is required | . ",
    "url": "/notes/robust_control.html#h_infty-synthesis",
    
    "relUrl": "/notes/robust_control.html#h_infty-synthesis"
  },"138": {
    "doc": "Robust Control",
    "title": "\\(H_\\infty\\) example modeling car tire over a bump",
    "content": "System Setup . \\(H_\\infty\\) Setup . A controller that takes two measured external signals, \\(S_d\\) suspension travel and \\(a_d\\) body acceleration. ",
    "url": "/notes/robust_control.html#h_infty-example-modeling-car-tire-over-a-bump",
    
    "relUrl": "/notes/robust_control.html#h_infty-example-modeling-car-tire-over-a-bump"
  },"139": {
    "doc": "Robust Control",
    "title": "\\(\\mu\\) Synthesis",
    "content": "\\(\\mu\\) synthesis is an extension of \\(H_\\infty\\). It solves the same problem but try to minimize the worst case gain over the entire uncertainty space. It aims to reduce the impact of model uncertainty in \\(H_\\infty\\). ",
    "url": "/notes/robust_control.html#mu-synthesis",
    
    "relUrl": "/notes/robust_control.html#mu-synthesis"
  },"140": {
    "doc": "Robust Control",
    "title": "D-K Iteration.",
    "content": ". | Run \\(H_\\infty\\) to find a nomial controller | Checks robustness | Scales the problem based on the uncertainty in the system and runs another \\(H_\\infty\\) | . ",
    "url": "/notes/robust_control.html#d-k-iteration",
    
    "relUrl": "/notes/robust_control.html#d-k-iteration"
  },"141": {
    "doc": "Robust Control",
    "title": "Robust Control",
    "content": " ",
    "url": "/notes/robust_control.html",
    
    "relUrl": "/notes/robust_control.html"
  },"142": {
    "doc": "Root Locus Analysis",
    "title": "Root Locus Analysis",
    "content": " ",
    "url": "/notes/root-locus.html",
    
    "relUrl": "/notes/root-locus.html"
  },"143": {
    "doc": "Root Locus Analysis",
    "title": "Poles and Zeros",
    "content": ". | The stability of an LTI system depends solely on the poles of its transfer function, including stability, speed of decay/growth, or natural oscillaitons. | Zeros (roots of the numerator) don‚Äôt directly affect stability because they don‚Äôt appear in the characteristic equation that governs the natural modes of the system. | Poles define how the system naturally behaves (transients, stability). Zeroes shape how the system reacts to inputs (modify transients, steady-state gain/phase, can cancel or distort modes) . | . What can Zeros do? . | Transient Shape and Overshoot . | Zeros can introduce additional terms in the time response that can increase or decrease overshoot, depending on their location. | A zero close to the origin (s = 0) or near the imaginary axis can significantly change the transient waveform. | . | Direction and Phase . | Zeros affect the phase of the frequency response. | . | Magnitude Shaping . | Zeros can boost or attenuate specific frequency components, affecting bandwidth and disturbance rejection. | . | . ",
    "url": "/notes/root-locus.html#poles-and-zeros",
    
    "relUrl": "/notes/root-locus.html#poles-and-zeros"
  },"144": {
    "doc": "Root Locus Analysis",
    "title": "Root Locus plot",
    "content": ". Where \\(\\mathcal{Z}\\) is the damping ratio. \\(\\mathcal{Z}=1\\) means critically damped, \\(\\mathcal{Z}&lt;1\\) means underdamped and \\(\\mathcal{Z}&gt;1\\) means over damped. The radial lines denote the lines of constant damping ratio \\(\\mathcal{Z}=cos(\\phi)\\), which defines a cone of damping ratio to satisfy design specs. Typical Design Requiremnts - Applications of Root Locus Plots . What is a Root Locus Plot? . root locus analysis is a graphical method for examining how the roots of a system change with variation of a certain system parameter, commonly a gain within a feedback system. Setting up Root Locus Plot . We need to get the pole to the correct form 1 + G(s) = 0 . ",
    "url": "/notes/root-locus.html#root-locus-plot",
    
    "relUrl": "/notes/root-locus.html#root-locus-plot"
  },"145": {
    "doc": "Root Locus Analysis",
    "title": "10 Rules of Root Locus",
    "content": "Setting the system up in this form: \\(1 + K \\frac{Q(s)}{P(s)}\\) . let . n = number of poles of G(s) (also the number of loci), the open loop transfer function m = number of zeros of G(s) l = 0, 1, 2, 3‚Ä¶ natural numbers q=order of repeated pole or zero \\(\\psi_{p} = \\text{angle from a pole}\\). Connect each pole with the pole/zero of interest, the angle between that line and positive x axis is \\(\\psi_p\\) \\(\\psi_{z} = \\text{angle from a zero}\\). Connect each zero with the pole/zero of interest, the angle between that line and positive x axis is \\(\\psi_z\\) . A root refers to a closed-loop pole of the system for a particular value of the gain K. Rule 1: There are n lines (loci), where \\(n = max(deg(Q), deg(P))\\) . Rule 2: As K increases from 0 to \\(\\infty\\), the closed loop poles move from the poles of open loop \\(G(s)\\) to the zeroes of open loop \\(G(s)\\) - if there are same number of poles and zeroes, they form a pair the roots travel from one pole to a zero. - if there are more Poles than Zeroes, the lines from the extra poles go to \\(\\infty\\) - if there are more Zeroes than Poles, the lines come from infinity to the extra zeroes . Rule 3: When roots are complex, they occur in conjugate pairs and move together but mirrored across the real plane . Rule 4: At no time will the same root cross over its path - Paths of other roots may cross each other . Rule 5: The portion of the real axis to the left of an odd number of open loop poles and zeroes are part of the loci - Another way to restate: For K&gt;0, loci exist on the real axis to the left of odd numbered poles and zeroes . Rule 6: Lines leave and enter the real axis at \\(90^\\circ\\). Rule 7: If there are not enough poles or zeroes to make a pair then the extra lines go to (for poles) or come from (for zeroes) infinity. Rule 8: Line go to infinity along asymptotes - The angles of the asymptotes, \\(\\phi_{A} = \\frac{(2l+1)}{n - m} * 180^\\circ\\) - Asymptotes intercept the real axis at \\(\\sigma_{0}\\) (ie. centroid of the asymptotes), \\(\\sigma = \\frac{\\Sigma \\text{finite poles} - \\Sigma \\text{finite zeroes}}{n - m}\\) - Angle of departure from a pole: \\(\\frac{1}{q}(\\Sigma(\\psi_z)-\\Sigma(\\psi_p)-180-360l)\\) . Rule 9: If there are at least two lines to infinity, then the sum of all roots is constant . Rule 10: K going from 0 to \\(-\\infty\\) can be drawn by reversing rule 5 and adding \\(180^\\circ\\) to the asymptote angles. More details on the 10 rules . Rule 2: \\(P(s) +KQ(s) = 0\\) by re-arranging the terms. When K = 0, P(s) = 0, which is the definition of poles for G(s). As K increases, more emphasis is put on Q(s) . Rule 9: . ",
    "url": "/notes/root-locus.html#10-rules-of-root-locus",
    
    "relUrl": "/notes/root-locus.html#10-rules-of-root-locus"
  },"146": {
    "doc": "Stability Analysis",
    "title": "Sensor Fusion",
    "content": " ",
    "url": "/notes/senser_fusion.html#sensor-fusion",
    
    "relUrl": "/notes/senser_fusion.html#sensor-fusion"
  },"147": {
    "doc": "Stability Analysis",
    "title": "Definition",
    "content": "Sensor fusion is a technique that combines two or more data sources in a way taht geneartes a more consistent, accurate, and dependable understanding of the system. ",
    "url": "/notes/senser_fusion.html#definition",
    
    "relUrl": "/notes/senser_fusion.html#definition"
  },"148": {
    "doc": "Stability Analysis",
    "title": "Advantages and Use Cases",
    "content": ". | It can increase the quality of the data by fusing either two sensors of either the same type or different types together. | It can increase reliability. | It can estimate unmeasured states. | It can be used to increase coverage. | . ",
    "url": "/notes/senser_fusion.html#advantages-and-use-cases",
    
    "relUrl": "/notes/senser_fusion.html#advantages-and-use-cases"
  },"149": {
    "doc": "Stability Analysis",
    "title": "Sensor Fusion Examples",
    "content": " ",
    "url": "/notes/senser_fusion.html#sensor-fusion-examples",
    
    "relUrl": "/notes/senser_fusion.html#sensor-fusion-examples"
  },"150": {
    "doc": "Stability Analysis",
    "title": "Attitude and heading reference system (AHRS)",
    "content": "To defin an orientation: . | Reference Frame . | Specify rotation . | . Measuring Attitude and Heading . Sensors - IMU (Magnetometer, Accelerometer, and Gyro) . The absolute orientation for a static object can be determined just with M and A and taking cross products. Magnetometer measures the strength and direction of a magnetic field and determines heading relative to the Earth‚Äôs magnetic north. - readings can be corrupted by other magnetic sources. - Hard Iron sources (Magnet or Coil) shift the sphere, soft irons (nails) distorts the sphere. Sphere refers to - needs to calibrate by rotate the device around . Accelerometer measures acceleration . - if the accelerometer is not at center of rotation, readings can be off. - linear acceleration can corrcupt Acc measurement of \"down\" . Gyro measures angular rate - Dead reckoning refers to integrating gyro readings (integration is a low pass filter, which filters out high frequency noise) - Gyros have drift . Sensor Fusion algorithm for IMU . | Initialize attitude | Use mag field and gravity to correct gyro drift | . In complementary filter, the user decides how much accel+mag and gyro data need to be trusted. Kalman filter automatically computes the confidence. ",
    "url": "/notes/senser_fusion.html#attitude-and-heading-reference-system-ahrs",
    
    "relUrl": "/notes/senser_fusion.html#attitude-and-heading-reference-system-ahrs"
  },"151": {
    "doc": "Stability Analysis",
    "title": "Sensor Fusion with GPS and IMU: Algorithm - Extended Kalman",
    "content": "GPS measured velocity and position. If GPS reading doesn‚Äôt need to be very accurate or fast, adding IMU is not helping much. (driving with google maps) If GPS reading needs to be accurate and fast velocity constantly changing, adding IMU helps. (drone flying around obstacles) . Estimating the sensor bias is extremely imporant because bias drifts over time. Step 1: Initializing the filter . 28 state kalman state vector: . | Orientation (4 states quaternion) | Angular Velocity(XYZ) (3) where XYZ means angular rates about body x,y,z, axes | Position (NED) (3) | Velocity (NED) (3) | Acceleration (NED) (3) | Accelerometer Bias (XYZ) (3) | Geomagnetic Field Vector (NED) (3) | Magnetometer Bias (XYZ) (3) | . If no estimates of sensor bias is available at system start, let the kalman filter converge to the correct solution while the vehicle is stationary. Note: Extended Kalman linearizes the nonlinear model at current estimate and uses the linear model to predict state into the future. If the filter is not initialized close to the true state, the linearization result would deviate and estimate would not converge. Initializing a real system . Step 2: Kalman . Predict and Correct . | Predict the state based on model and keep track of confidence (Process Noise). When new measurement comes in with measurement noise, the filter compare the measurement with predicted model and corrects its estimate based on the confidence. | If there is an update from any of the sensors, update the state based on the relative confidence based on the estimate and the measurement. | The sensor can therefore run with asyncronous measurements | . | . ",
    "url": "/notes/senser_fusion.html#sensor-fusion-with-gps-and-imu-algorithm---extended-kalman",
    
    "relUrl": "/notes/senser_fusion.html#sensor-fusion-with-gps-and-imu-algorithm---extended-kalman"
  },"152": {
    "doc": "Stability Analysis",
    "title": "Tracking Remote Objects",
    "content": " ",
    "url": "/notes/senser_fusion.html#tracking-remote-objects",
    
    "relUrl": "/notes/senser_fusion.html#tracking-remote-objects"
  },"153": {
    "doc": "Stability Analysis",
    "title": "Interacting Multiple Model Filter (IMM) - How to track a single remote object with remote sensors",
    "content": "Tracking a remote object. Key difference: with Kalman filters, one knows the state model to predict the future state of an object. However, when tracking a remote object, we typically don‚Äôt have access to the input to the plant. Cooperative Tracking: tracked object shares control input. Unkown inputs are taken into account by process noise. Uncoorperative Tracking: tracked object does not share control input. Uncooperative tracking with a remote object . Trade-off between High process noise and low process noise. Example: constant velocity model but don‚Äôt know the exact control inputs . Scheme: Increase Process noise to trust prediction less and trust measurement more. This would reduce noise when the actual dynamics is not constant velocity. However, this comes at the cost of error for area which the model predicts the dynamics well (constant velocity case). Interactive Multiple Model Filter (single object tracking) . To have one model for each type of motion. Allowing each model to interact to reduce transient error . Interactive Multi-Model filter vs Multi-Model Filter . | IMM reduces transient error compared to independent models in Multi-Model filters | IMM blends all models together based on the likelihood of each representing the true motion | . Disadvantages of too many models in IMM . A large number of models for IMM can introduce both computationall cost and performance hit . Performance: . | More models means more transitions between models | Harder to know when to make a transitions | . Try to find the smallest number of models that adequetly predicts the possible motion of the object you‚Äôre tracking. ",
    "url": "/notes/senser_fusion.html#interacting-multiple-model-filter-imm---how-to-track-a-single-remote-object-with-remote-sensors",
    
    "relUrl": "/notes/senser_fusion.html#interacting-multiple-model-filter-imm---how-to-track-a-single-remote-object-with-remote-sensors"
  },"154": {
    "doc": "Stability Analysis",
    "title": "Tracking Multiple Remote Objects",
    "content": ". Challenges of multi-object tracking . Date Association Problem . | Uncertainty in observations and predictions play a major role in the challenges. | Objects can be close enough to accurately attribute a measurement to an object. | Uncertainty can be great enough that a measurement can be of more than one object. | . Track Maintanence Problem . | The number of objects being tracked is not fixed. | Sometimes tracks need to be created or removed (stop tracking when plane lands). | False positive or missed detection measurements | . Diagram Breakdown . | Observations . | Measured Quantities: range, range rate, line of sight | Measured Attributes: target type, ID number, object shape | . | Assignment: Matching an Observation to a Tracked Object . | Mahalanobis distance: the closest probability distance (normalized by stadard deviation) | Joint Probabilistic Data Association (JPDA): does not commit to a single observation and assgin one object to one track but instead make a weighted combinations of all neighboring observations (closer ones have bigger weight) | . | Track Maintenance (deleting and creating track) . | Delete a track if not detected at least P times in R updates with R and P tunable. | Create a track: tentative track an observation not assigned to an object. Confirm trakc if object has been detected M times in N updates. | . | Estimation Filters . | Each filter runs. Fused measured state \\(\\hat{x}\\) and fused covariance \\(\\bar{P}\\) are captured. | . | Gating . | Screens all detections to detect which detections are feasible to look at for assignment. | Ignores detections outside of a region, also called ‚Äúgate‚Äù. | . | . ",
    "url": "/notes/senser_fusion.html#tracking-multiple-remote-objects",
    
    "relUrl": "/notes/senser_fusion.html#tracking-multiple-remote-objects"
  },"155": {
    "doc": "Stability Analysis",
    "title": "Track Level Fusion",
    "content": "Central-level tracking vs Sensor-level Tracking and Track Level Fusion . source tracks provide their own track with distribution. The track fuser determines if these are the same object or different objects . sensor level tracking: . ",
    "url": "/notes/senser_fusion.html#track-level-fusion",
    
    "relUrl": "/notes/senser_fusion.html#track-level-fusion"
  },"156": {
    "doc": "Stability Analysis",
    "title": "Advantages and Challenges of Track Level Fusion",
    "content": "Advantages . | Access to data . | TLF is necessary if you don‚Äôt have access to raw sensor data. For instance, a Lidar sensor that doesn‚Äôt return point cloud but instead the tracks. No track level data available | . | Bandwidth . | Transmitting data from sensors in real time to computing centers that runs tracking. | Track level fusion data is smaller than raw sensor data. | . | Compute . | Local computer can pre-process data to reduce processing time. | . | Specialize . | TLF allows sensor level trackers to be specialized to the particular sensor type. | Since these trackers need motion and sensor models. Track maintenance needs to be tuned. | . | . Challengs of TLF . | Reduced Accuracy . | Track distills sensor raw data to a lot less info. We may remove useful info. | . | Correlated noise . | If tracks are correlated, then we can‚Äôt multiply the probabilities like Kalman. | . | . ",
    "url": "/notes/senser_fusion.html#advantages-and-challenges-of-track-level-fusion",
    
    "relUrl": "/notes/senser_fusion.html#advantages-and-challenges-of-track-level-fusion"
  },"157": {
    "doc": "Stability Analysis",
    "title": "Appendix",
    "content": " ",
    "url": "/notes/senser_fusion.html#appendix",
    
    "relUrl": "/notes/senser_fusion.html#appendix"
  },"158": {
    "doc": "Stability Analysis",
    "title": "IMM walkthrough",
    "content": "Interacting Multiple Model (IMM): One Cycle . | Model-conditioned reinitialization (mixing), for each model \\( m_i \\in \\mathcal{M} \\) . | Predicted model probability \\[ \\mu_{k|k-1}^{(i)} = \\sum_{j} \\pi_{ji}\\,\\mu_{k-1}^{(j)} \\] | Mixing probabilities (previous model \\(j\\) given current \\(i\\)) \\[ \\mu_{k-1}^{j|i} = \\frac{\\pi_{ji}\\,\\mu_{k-1}^{(j)}}{\\mu_{k|k-1}^{(i)}} \\] | Mixed initial state \\[ \\bar{x}_{k-1|k-1}^{(i)} = \\sum_{j} \\hat{x}_{k-1|k-1}^{(j)} \\,\\mu_{k-1}^{j|i} \\] | Mixed initial covariance \\[ \\bar{P}_{k-1|k-1}^{(i)} = \\sum_{j}\\Big( P_{k-1|k-1}^{(j)} + (\\bar{x}_{k-1|k-1}^{(i)}-\\hat{x}_{k-1|k-1}^{(j)}) (\\bar{x}_{k-1|k-1}^{(i)}-\\hat{x}_{k-1|k-1}^{(j)})^\\top \\Big)\\,\\mu_{k-1}^{j|i} \\] | . | Model-conditioned filtering (per model) . | Prediction \\[ \\hat{x}_{k|k-1}^{(i)} = F_{k-1}^{(i)}\\,\\bar{x}_{k-1|k-1}^{(i)},\\qquad P_{k|k-1}^{(i)} = F_{k-1}^{(i)}\\,\\bar{P}_{k-1|k-1}^{(i)}\\,(F_{k-1}^{(i)})^\\top + Q_{k-1}^{(i)} \\] | Update \\[ \\tilde{z}_{k}^{(i)} = z_k - H_{k}^{(i)} \\hat{x}_{k|k-1}^{(i)},\\qquad S_{k}^{(i)} = H_{k}^{(i)} P_{k|k-1}^{(i)} (H_{k}^{(i)})^\\top + R_{k}^{(i)} \\] \\[ K_{k}^{(i)} = P_{k|k-1}^{(i)} (H_{k}^{(i)})^\\top (S_{k}^{(i)})^{-1} \\] \\[ \\hat{x}_{k|k}^{(i)} = \\hat{x}_{k|k-1}^{(i)} + K_{k}^{(i)} \\tilde{z}_{k}^{(i)},\\qquad P_{k|k}^{(i)} = P_{k|k-1}^{(i)} - K_{k}^{(i)} S_{k}^{(i)} (K_{k}^{(i)})^\\top \\] | . | Model probability update (per model) . | Likelihood \\[ L_{k}^{(i)} = \\mathcal{N}\\!\\big(\\tilde{z}_{k}^{(i)};\\; 0,\\; S_{k}^{(i)}\\big) \\] | Bayesian update \\[ \\mu_{k}^{(i)} = \\frac{\\mu_{k|k-1}^{(i)}\\, L_{k}^{(i)}}{\\sum_{j} \\mu_{k|k-1}^{(j)}\\, L_{k}^{(j)}} \\] | . | Estimate fusion . \\[ \\hat{x}_{k|k} = \\sum_{i} \\hat{x}_{k|k}^{(i)} \\,\\mu_{k}^{(i)} \\] \\[ P_{k|k} = \\sum_{i}\\Big( P_{k|k}^{(i)} + (\\hat{x}_{k|k}-\\hat{x}_{k|k}^{(i)})(\\hat{x}_{k|k}-\\hat{x}_{k|k}^{(i)})^\\top \\Big)\\,\\mu_{k}^{(i)} \\] | . Symbol notes . | \\(\\pi_{ji}\\): probability of switching from model \\(j\\) to model \\(i\\) | \\(\\mu_{k}^{(i)}\\): probability model \\(i\\) is correct at time \\(k\\) | \\(\\hat{x}, P\\): state mean and covariance; bars \\((\\bar{\\cdot})\\) denote mixed (pre-prediction) quantities | \\(F^{(i)}, Q^{(i)}\\): dynamics and process noise for model \\(i\\) | \\(H^{(i)}, R^{(i)}\\): measurement model and noise for model \\(i\\) | \\(\\tilde{z}\\): measurement residual; \\(S\\): residual covariance; \\(K\\): Kalman gain | . ",
    "url": "/notes/senser_fusion.html#imm-walkthrough",
    
    "relUrl": "/notes/senser_fusion.html#imm-walkthrough"
  },"159": {
    "doc": "Stability Analysis",
    "title": "Stability Analysis",
    "content": " ",
    "url": "/notes/senser_fusion.html",
    
    "relUrl": "/notes/senser_fusion.html"
  },"160": {
    "doc": "Stability Analysis",
    "title": "Stability Analysis",
    "content": " ",
    "url": "/notes/stability.html",
    
    "relUrl": "/notes/stability.html"
  },"161": {
    "doc": "Stability Analysis",
    "title": "Stability Margins - Gain and Phase Margins",
    "content": "In simple terms, Gain and Phase margins are the safe net and the extra that protects us from instability. less margin = less stable . Note: Gain crossover frequency is used to caluclate Phase Margin. Phase crossover frequency is used to caculate Gain Margin. The Gain and PhaseMargins are defined with respect to open-loop transfer function, but the margins are not intrinsic properties of the open-loop system alone, and are only meaningful for the corresponding closed-loop system. Gain Margin . The gain margin (GM) is defined at the phase crossover frequency \\(\\omega_{pc} \\text{ where } \\angle L(j\\omega_{pc}) = -180^\\circ\\): . \\[GM = \\frac{1}{|L(j\\omega_{pc})|}\\] In decibels (dB): . \\[GM_{\\text{dB}} = -20 \\log_{10} |L(j\\omega_{pc})|\\] If there are multiple Phase crossover frequencies \\(\\omega_{pc}\\), use the most conservative Gain Margin. Phase Margin . The phase margin (PM) is defined at the gain crossover frequency \\(\\omega_{gc}\\) where \\(|L(j\\omega_{gc})| = 1\\): . \\[PM = 180^\\circ + \\angle L(j\\omega_{gc})\\] Margins and Sensitivity . Peaks in Sensitivity Plots are directly correlated with Gain and Phase Margins. The smaller the margins, the bigger the peak. ",
    "url": "/notes/stability.html#stability-margins---gain-and-phase-margins",
    
    "relUrl": "/notes/stability.html#stability-margins---gain-and-phase-margins"
  },"162": {
    "doc": "Stability Analysis",
    "title": "Why use Disk Margin?",
    "content": ". | Even though increasing delay or increasing gain individually (reducing GM and PM respectively) may not cause the system to be unstable, adding a mix of the two can unstabilize the system. The disk margin therefore needs to be considered. To anaylze the effect of adding phase and gain, use Nyquist Plot. | Disk margin can be used on MIMO. | . ",
    "url": "/notes/stability.html#why-use-disk-margin",
    
    "relUrl": "/notes/stability.html#why-use-disk-margin"
  },"163": {
    "doc": "Stability Analysis",
    "title": "Disk Margin",
    "content": ". The disk reads ‚ÄúGiven \\(e=0.0\\), the maximum disk margin is 0.56‚Äù . Parameters of the disk . The disk must be fit entirely in the stable region and includes the nominal point \\(f =1 + 0i\\) . | Skew factor \\(e\\). how far off the center of the disk is to the nominal point. | \\(\\alpha\\) measures the size of the disk. It represents the size of the disk given a certain \\(e\\) such that the disk is entirely in the stable region. | . Disk Placement . You can choose where the disk is: . | If you think real system gain is bigger than model gain, use a bigger \\(e\\) . | If unsure, choose \\(e = 0.0\\) | . | Disk margin may not be conservative even if it may only covers a small area of stability zone. | in this case, while gain margin is bigger, at those bigger gain values, not much wiggle room for phase -&gt; not optimal | . | May need to check all three margins to ensure accurate representation of the stability. | Some systems are robust to pure phase or gain variations but not a mix of the two | . | . ",
    "url": "/notes/stability.html#disk-margin",
    
    "relUrl": "/notes/stability.html#disk-margin"
  },"164": {
    "doc": "Stability Analysis",
    "title": "Closed Loop Stability",
    "content": "In a non-unity feedback system whose feedback transfer function is \\(H(s)\\), the closed loop transfer function is \\(\\frac{G(s)}{1+GH}\\). We can study the stability of the closed loop transfer function by identifying the zeros of \\(1+GH\\). Adding 1 to the Nyquist plot of the open loop transfer function shift the plot to the right by 1 . ",
    "url": "/notes/stability.html#closed-loop-stability",
    
    "relUrl": "/notes/stability.html#closed-loop-stability"
  },"165": {
    "doc": "Stability Analysis",
    "title": "Nyquist Criterion ‚Äî Bode/Nyquist Terms (Unity Feedback)",
    "content": "Cauchy‚Äôs Argument Principle . A contour in S-plane maps to a plot in W-plane. The phaser for any point on the contour is the same as the phaser for its mapped counterpart in the W-plane. The mapping is done by the transfer function. To compute the phaser: . | Choose a point in the S plane. | Draw phasers by connecting that point of interest to all the zeros and poles in the S-plane. | To compute the magnitude of the phaser in W-plane, multiply all magnitudes of the zero phasers (in S-plane) and divide by the magnitudes of the pole phasers (in S-plane). | To compute the phase of the phaser in W-plane, add the zero phases in S-plane and subtract the pole phases in S-plane. The phase here refers to the angle between the phaser and the positve x-axis. | . We use the above method to trace a contour in the S-plane and visualize the plot on the W-plane. Notes: . | Given the above steps, we can see that if the contour does not include any poles or zeroes, the phase in W-plane would never go around \\(360^\\circ\\). | If the contour encircles a pole, the resulting plot on W-plane circles the origin in the counter clockwise direction. This is because we are subtracting pole phases. | . | for each encircled pole on a contour, there‚Äôs a circle around the origin on the plot in W-plane. | . | Encircling a zero in the S-plane does similar things in W-plane but flip the direction to clockwise. | If there are same number of zeros as poles, the resulting plot in W-plane does not encircle the orgin at all. | . We can get the difference between the number of poles and zeros in the S-plane just by looking at if the plot in W-plane encircles the origin and if so, in what direction. | If the plot in W-plane (ie, after propagating through the transfer function) encircles the origin once in the clockwise direction, there is 1 more zero than poles in the original system. | If the plot in W-plane (ie, after propagating through the transfer function) encircles the origin once in the counter-clockwise direction, there is 1 more pole than zeros in the original system. | If the plot encircles the origin twice in the clockwise direction, there are 2 more zeros than poles in the original system. | . ",
    "url": "/notes/stability.html#nyquist-criterion--bodenyquist-terms-unity-feedback",
    
    "relUrl": "/notes/stability.html#nyquist-criterion--bodenyquist-terms-unity-feedback"
  },"166": {
    "doc": "Stability Analysis",
    "title": "Using Cauchy‚Äôs Argument Principle for Closed-loop Stability Analysis (Are there any zeroes in RHP for \\(1+L(s)\\))",
    "content": "Why RHP zeros of \\(1+L(s)\\)? . | An open loop system is stable if and only if there is no RHP poles, which happens when the denominator of L(s) equals 0. | Since \\(1+L(s)\\) is the new denominator of the closed loop transfer function \\(\\frac{G}{1+GH}\\), we want there to be no RHP zeros. | . Using Cauchy‚Äôs Argument Principle and Nyquist Contour . Since we need to know if there is any RHP zeros for \\(1+GH\\), we need a contour that encloses the right half plane - \\(Nyquist contour\\) on S-plane. When the Nyquist contour is mapped through a transfer function to the W-plane, we get a Nyquist plot. The Nyquist plot is plotted by pluggin in every single frequency on the imaginary axis and all the points along with infinity on the RHP in the S-plane. Instead of 1+GH, we can shift the plane to the left by -1 and only investigate the Open-loop transfer function \\(GH\\). By looking at the Nyquist plot, we can see how many times the -1 point is encircled and in which direction. Steps: . | Get Nyquist plot of Open-loop transfer function \\(G(s)H(s)\\) | Count encirclements of -1, note direction. | Determine how many more poles or zeros are in the RHP. We can do this since we typically know how many poles are in the RHP for \\(GH\\) | . Therefore, . \\[Z=N+P\\] where Z is the number of zeros of \\(1+GH\\), N is the number of times the Nyquist plot encircles -1 in the clockwise direction, and P is the number of open loop poles in the RHP (unstable open-loop poles) . To guarantee no RHP zeros for \\(1+L(s)\\), we need to have 1 counterclockwise encirclement for every open-loop RHP pole. This prperty allows to use Nyquist plots to analyze both stable and unstable open-loop system, unlike the bode plot, which only pertains to stable open loop systems. Nyquist Criterion . Setup. Let the open-loop transfer be \\(G(s)\\) for a unity-feedback loop with closed-loop characteristic \\(1+G(s)=0\\). Let: . | \\(P\\) = number of open-loop poles of \\(G(s)\\) in the right-half plane (RHP), | \\(N\\) = number of clockwise encirclements of the Nyquist critical point \\(-1+0j\\) by the Nyquist plot of \\(G(j\\omega)\\) (standard Nyquist contour), | \\(Z\\) = number of closed-loop poles in the RHP. | . General Nyquist criterion. \\(Z = N + P.\\) The closed loop is stable iff \\(Z=0\\). Equivalently, the Nyquist plot must encircle \\(-1\\) clockwise exactly \\(N=-P\\) times. Common special case (open-loop stable, i.e., \\(P=0\\)). If \\(G(s)\\) has no RHP poles and no poles on the \\(j\\omega\\)-axis (aside from allowable integrators handled with the modified contour), then: . | Closed loop is stable iff the Nyquist plot of \\(G(j\\omega)\\) does not encircle \\(-1+0j\\) (i.e., \\(N=0 \\Rightarrow Z=0\\)). | . Bode-plot restatements (margins) . Let \\(\\omega_{gc}\\) be a gain-crossover frequency where \\(|G(j\\omega_{gc})|=1\\), and let \\(\\omega_{pc}\\) be a phase-crossover frequency where \\(\\angle G(j\\omega_{pc})=-180^\\circ\\). | Phase margin condition (at gain crossover): \\(|G(j\\omega_{gc})|=1 \\quad \\Rightarrow \\quad \\angle G(j\\omega_{gc}) &gt; -180^\\circ\\) (positive phase margin). This ensures the Nyquist plot does not cross the real axis at or left of \\(-1\\). | Gain margin condition (at phase crossover): \\(\\angle G(j\\omega_{pc})=-180^\\circ \\quad \\Rightarrow \\quad |G(j\\omega_{pc})| &lt; 1\\) (positive gain margin). This keeps the Nyquist locus inside the unit circle when it is at \\(-180^\\circ\\), avoiding the point \\(-1\\). | . If both conditions hold for all relevant crossovers and \\(P=0\\), the loop has positive stability margins and the closed loop is stable. Notes/Caveats . | If \\(P&gt;0\\) (open-loop unstable), you must have exactly \\(N=-P\\) clockwise encirclements of \\(-1\\). Simple ‚Äúmargin checks‚Äù at crossovers are insufficient without accounting for \\(P\\). | Poles on the imaginary axis (e.g., pure integrators) require the standard indentation in the Nyquist contour; apply the modified criterion accordingly. | The above statements presume unity feedback; for non-unity feedback, apply the criterion to the appropriate open-loop function that multiplies the feedback path. | . ",
    "url": "/notes/stability.html#using-cauchys-argument-principle-for-closed-loop-stability-analysis-are-there-any-zeroes-in-rhp-for-1ls",
    
    "relUrl": "/notes/stability.html#using-cauchys-argument-principle-for-closed-loop-stability-analysis-are-there-any-zeroes-in-rhp-for-1ls"
  },"167": {
    "doc": "Lyapunov Stability",
    "title": "Chain Rule ‚Üí Lie Derivative ‚Üí Lyapunov Stability (Autonomous Systems)",
    "content": " ",
    "url": "/nonlinear_notes/stability.html#chain-rule--lie-derivative--lyapunov-stability-autonomous-systems",
    
    "relUrl": "/nonlinear_notes/stability.html#chain-rule--lie-derivative--lyapunov-stability-autonomous-systems"
  },"168": {
    "doc": "Lyapunov Stability",
    "title": "Setup",
    "content": "Consider an autonomous system \\(\\dot x = f(x),\\quad x\\in\\mathbb{R}^n,\\) and a scalar candidate \\(V:\\mathbb{R}^n\\to\\mathbb{R}\\) (no explicit time dependence). ",
    "url": "/nonlinear_notes/stability.html#setup",
    
    "relUrl": "/nonlinear_notes/stability.html#setup"
  },"169": {
    "doc": "Lyapunov Stability",
    "title": "Chain rule along trajectories",
    "content": "Let \\(x(t)\\) be a trajectory of \\(\\dot x=f(x)\\). Since \\(V=V(x)\\) has no explicit \\(t\\), \\(\\frac{d}{dt}V\\big(x(t)\\big) = \\nabla V(x)^\\top \\dot x = \\nabla V(x)^\\top f(x).\\) . ",
    "url": "/nonlinear_notes/stability.html#chain-rule-along-trajectories",
    
    "relUrl": "/nonlinear_notes/stability.html#chain-rule-along-trajectories"
  },"170": {
    "doc": "Lyapunov Stability",
    "title": "Lie derivative",
    "content": "The Lie derivative of \\(V\\) along \\(f\\) is the directional derivative \\(\\mathcal{L}_f V(x) \\; = \\nabla V(x)^\\top f(x).\\) Hence, along solutions, \\(\\boxed{\\ \\dot V(x) \\equiv \\frac{d}{dt}V(x(t)) = \\mathcal{L}_f V(x)\\ }.\\) . ",
    "url": "/nonlinear_notes/stability.html#lie-derivative",
    
    "relUrl": "/nonlinear_notes/stability.html#lie-derivative"
  },"171": {
    "doc": "Lyapunov Stability",
    "title": "Lyapunov stability (equilibrium at the origin)",
    "content": "Assume \\(x^\\star=0\\) is an equilibrium: \\(f(0)=0\\). Let \\(\\alpha_i\\) be class-\\(\\mathcal{K}_\\infty\\) functions. Stability (Lyapunov) . If there exists \\(V:\\mathbb{R}^n\\to\\mathbb{R}_{\\ge 0}\\) and \\(\\alpha_1,\\alpha_2\\in\\mathcal{K}_\\infty\\) such that, in a neighborhood of \\(0\\), \\(\\alpha_1(\\|x\\|)\\le V(x)\\le \\alpha_2(\\|x\\|),\\quad \\dot V(x)=\\mathcal{L}_f V(x)\\le 0,\\) then \\(x=0\\) is stable. Asymptotic stability . If, in addition, there exists \\(\\alpha_3\\in\\mathcal{K}_\\infty\\) with \\(\\dot V(x)=\\mathcal{L}_f V(x)\\le -\\,\\alpha_3(\\|x\\|)\\quad(\\text{for }x\\neq 0),\\) then \\(x=0\\) is asymptotically stable. Exponential stability (sufficient condition) . If there exist \\(c&gt;0\\) and \\(\\alpha_1,\\alpha_2\\in\\mathcal{K}_\\infty\\) such that \\(\\alpha_1(\\|x\\|)\\le V(x)\\le \\alpha_2(\\|x\\|),\\quad \\dot V(x)\\le -\\,c\\,V(x),\\) then \\(x=0\\) is (locally) exponentially stable. Global versions . If the above properties hold for all \\(x\\in\\mathbb{R}^n\\) and \\(V\\) is radially unbounded (\\(V(x)\\to\\infty\\) as \\(\\|x\\|\\to\\infty\\)), then the corresponding stability property is global. LaSalle‚Äôs invariance principle (autonomous) . If \\(V\\) is positive definite and \\(\\dot V(x)=\\mathcal{L}_f V(x)\\le 0\\), then every trajectory approaches the largest invariant set contained in \\(\\mathcal{S} \\;=\\; \\{\\,x:\\ \\mathcal{L}_f V(x)=0\\,\\}.\\) If the only invariant set in \\(\\mathcal{S}\\) is \\(\\{0\\}\\), then the origin is asymptotically stable. ",
    "url": "/nonlinear_notes/stability.html#lyapunov-stability-equilibrium-at-the-origin",
    
    "relUrl": "/nonlinear_notes/stability.html#lyapunov-stability-equilibrium-at-the-origin"
  },"172": {
    "doc": "Lyapunov Stability",
    "title": "Quick checklist",
    "content": ". | \\(V(0)=0\\), \\(V(x)&gt;0\\) for \\(x\\neq 0\\) (positive definite); preferably radially unbounded. | Compute \\(\\dot V=\\mathcal{L}_f V=\\nabla V^\\top f\\). | Aim for \\(\\dot V\\le 0\\) (stability), \\(\\dot V&lt;0\\) or LaSalle conditions (asymptotic), or \\(\\dot V\\le -cV\\) (exponential). | . ",
    "url": "/nonlinear_notes/stability.html#quick-checklist",
    
    "relUrl": "/nonlinear_notes/stability.html#quick-checklist"
  },"173": {
    "doc": "Lyapunov Stability",
    "title": "Lyapunov Stability",
    "content": " ",
    "url": "/nonlinear_notes/stability.html",
    
    "relUrl": "/nonlinear_notes/stability.html"
  },"174": {
    "doc": "State Space Representation",
    "title": "State Space Representation",
    "content": "Coming soon‚Ä¶ . ",
    "url": "/notes/state-space.html",
    
    "relUrl": "/notes/state-space.html"
  },"175": {
    "doc": "State Estimation",
    "title": "State Estimation",
    "content": " ",
    "url": "/notes/state_estim.html",
    
    "relUrl": "/notes/state_estim.html"
  },"176": {
    "doc": "State Estimation",
    "title": "Measurement Model",
    "content": "\\(\\dot{x}=Ax+Bu, y=Cx, x\\in\\mathbb{R^n}, y \\in\\mathbb{R^p}\\) . ",
    "url": "/notes/state_estim.html#measurement-model",
    
    "relUrl": "/notes/state_estim.html#measurement-model"
  },"177": {
    "doc": "State Estimation",
    "title": "Observability",
    "content": "In simple terms, observability is if any state in x can be reproduced and deduced from measurements y(t) . ",
    "url": "/notes/state_estim.html#observability",
    
    "relUrl": "/notes/state_estim.html#observability"
  },"178": {
    "doc": "State Estimation",
    "title": "Observability Matrix",
    "content": "\\(\\mathbb{O} = \\begin{bmatrix} C \\\\ CA \\\\ CA^2 \\\\ \\vdots \\\\ CA^{n-1} \\end{bmatrix}\\) This is a tall matrix and therefore its rank is the column rank. Note that the C matrices are measurement matrices, not controllability matrices. | The system is observable if rank(O)=n. | The full state x can be estimated from y. | Degrees of Observability can be calculated from the Observability Gramian and the SVD | . ",
    "url": "/notes/state_estim.html#observability-matrix",
    
    "relUrl": "/notes/state_estim.html#observability-matrix"
  },"179": {
    "doc": "State Estimation",
    "title": "Kalman Filter (Linear Quadratic Estimator)",
    "content": "Notes . | Both Kalman Filter and LQR solve an algebraic Riccati Equation, yielding a closed-form solution | The algebraic Riccati Equation for Kalman filter is very similar to that of LQR. | Kalman filter gain (\\(K_{k}\\)) is derived by minimizing the estimate coveriance matrix \\(P_{k}\\) | . Kalman is a Full State Estimator that measures full state $x(t)$ given the knowledge of the measurement \\(y(t)\\) and control input \\(u(t)\\). The eigenvalues of the Kalman filter signifies how fast estimates converge to the true state. Pole placement can be performed on Kalman to find the optimal eigenvalues. More aggressive poles means Kalman will be more susceptible to external noise. Kalman Cost Function . \\(J= \\mathbb{E}[(x-\\hat{x})^T(x-\\hat{x})]\\) . Measurement Noise . \\(\\epsilon = x - \\hat{x} \\\\ \\dot{\\epsilon}=(A-KC) \\epsilon + w_{d} - Kw_{n}\\), where K is the Kalman gain and C is the measurement matrix, W_{d} is the process noise from system dynamics and w_{n} is the sensor noise . Two Major noises . | Model Noise \\(w_{d}\\) | Measurement Noise \\(w_{n}\\) if one is high, trust the other more. | . ",
    "url": "/notes/state_estim.html#kalman-filter-linear-quadratic-estimator",
    
    "relUrl": "/notes/state_estim.html#kalman-filter-linear-quadratic-estimator"
  },"180": {
    "doc": "SVD",
    "title": "Intuitive Interpretations",
    "content": " ",
    "url": "/notes/svd.html#intuitive-interpretations",
    
    "relUrl": "/notes/svd.html#intuitive-interpretations"
  },"181": {
    "doc": "SVD",
    "title": "Rotation, coordinate scaling, and reflection",
    "content": " ",
    "url": "/notes/svd.html#rotation-coordinate-scaling-and-reflection",
    
    "relUrl": "/notes/svd.html#rotation-coordinate-scaling-and-reflection"
  },"182": {
    "doc": "SVD",
    "title": "üéØ SVD Geometry Summary",
    "content": "For a real matrix M, the Singular Value Decomposition is: . \\[\\mathbf{M} = \\mathbf{U} \\boldsymbol{\\Sigma} \\mathbf{V}^*\\] üî∑ Square Matrix Case: \\(\\mathbf{M} \\in \\mathbb{R}^{m \\times m}\\) . | U and V* are real orthogonal matrices (rotations/reflections) | Œ£ scales each coordinate by singular values \\(\\sigma_i\\) | Geometrically: rotation/reflection ‚Üí scaling ‚Üí rotation/reflection | . üî∏ Determinant Interpretation . | \\(\\det(\\mathbf{M}) &gt; 0\\): U and \\(V^*\\) are both rotations or both reflections | \\(\\det(\\mathbf{M}) &lt; 0\\): One of U or \\(V^*\\) must involve reflection | \\(\\det(\\mathbf{M}) = 0\\): U and \\(V^*\\) can independently be rotations or reflections | . üî∑ Rectangular Matrix Case: $\\mathbf{M} \\in \\mathbb{R}^{m \\times n}$ . | M maps \\(\\mathbb{R}^n \\to \\mathbb{R}^m\\) | U and V* act on $\\mathbb{R}^m$ and $\\mathbb{R}^n$ respectively | Œ£: . | Scales the first $\\min(m, n)$ coordinates | Extends (pads) or truncates vector dimensions appropriately | . | . This decomposition reveals how any linear transformation can be interpreted geometrically using rotations/reflections and scaling. ",
    "url": "/notes/svd.html#-svd-geometry-summary",
    
    "relUrl": "/notes/svd.html#-svd-geometry-summary"
  },"183": {
    "doc": "SVD",
    "title": "SVD",
    "content": "SVD works on any matrix . ",
    "url": "/notes/svd.html",
    
    "relUrl": "/notes/svd.html"
  },"184": {
    "doc": "System ID",
    "title": "Motivation",
    "content": " ",
    "url": "/notes/system_id.html#motivation",
    
    "relUrl": "/notes/system_id.html#motivation"
  },"185": {
    "doc": "System ID",
    "title": "Model",
    "content": "Use Cases . | Controller Design 2. State Estimation 3. Formal Analysis 5. Simulation | . Model Components . | Structure - e.g. second order differential equations, frequency response, process model (with time delay), neural networks | Parameters - e.g. physical quantities - mass, spring constant | . How to create a model . Scenario 1: You know a lot about the physical system -&gt; white box approach: create model directly from first principles . Scenario 2: You don‚Äôt know much about the system -&gt; black box approach: pure system ID . Scenario 3: You combine first principles with fitting -&gt;grey box approach: use first principles to derive structure and fit parameters . ",
    "url": "/notes/system_id.html#model",
    
    "relUrl": "/notes/system_id.html#model"
  },"186": {
    "doc": "System ID",
    "title": "Linear System Identification",
    "content": "Linear, Nonlinear, Online and Recursive system ID. System ID is a data driven method . Choose a model structure that represents the system dynamics and fit a model to the data by picking the parameters . ",
    "url": "/notes/system_id.html#linear-system-identification",
    
    "relUrl": "/notes/system_id.html#linear-system-identification"
  },"187": {
    "doc": "System ID",
    "title": "System ID vs Curve fit",
    "content": "Curve fit \\(y=f(t)\\) . Curve fit only describes the sequence of data but doesn‚Äôt describe the underlying mechanisms that created the data. For instance, curve fitting cannot predict the data if system was initialized at different state or even different inputs. System ID $$y=f(u,y,t) . System ID takes into account of correlation between the data points, which depends on previous system state. ",
    "url": "/notes/system_id.html#system-id-vs-curve-fit",
    
    "relUrl": "/notes/system_id.html#system-id-vs-curve-fit"
  },"188": {
    "doc": "System ID",
    "title": "Typical System ID model candidates",
    "content": ". ",
    "url": "/notes/system_id.html#typical-system-id-model-candidates",
    
    "relUrl": "/notes/system_id.html#typical-system-id-model-candidates"
  },"189": {
    "doc": "System ID",
    "title": "System ID workflow",
    "content": ". ",
    "url": "/notes/system_id.html#system-id-workflow",
    
    "relUrl": "/notes/system_id.html#system-id-workflow"
  },"190": {
    "doc": "System ID",
    "title": "Selecting a Model Order",
    "content": "Hankel Singular Value . | Hankel Singular Values are caluclated by taking the SVD of the Hankel matrix. | Hankel Singular values can be plotted against model order to show redundant orders to reduce the system. | . ",
    "url": "/notes/system_id.html#selecting-a-model-order",
    
    "relUrl": "/notes/system_id.html#selecting-a-model-order"
  },"191": {
    "doc": "System ID",
    "title": "Modeling a Real System",
    "content": ". | Model the system. | Model the dynamics of disturbance. | . Whiteness and Correlation Tests . Residual: . | Initialize model at first data point (t=0), predict y at the next time step (t = 1). Caluclate error. | Initialize model at second data point (t=1), predict y at the next time step (t = 2). Calculate error. | . ‚Ä¶ . | Initialize model at n-th data point (t = n + 1), predict y at the next time step (t = n + 2). Calculate error. | . We have a residual curve. Residual Autocorrelation: If residual values are correlated with themselves in some way -&gt; there is unmodeled dynamics in disturbance model. Residual-Input Cross-Correlation: If residual values are highly cross-correlated with input -&gt; there is unmodeled dynamics in system model. ",
    "url": "/notes/system_id.html#modeling-a-real-system",
    
    "relUrl": "/notes/system_id.html#modeling-a-real-system"
  },"192": {
    "doc": "System ID",
    "title": "Nonlinear System ID",
    "content": " ",
    "url": "/notes/system_id.html#nonlinear-system-id",
    
    "relUrl": "/notes/system_id.html#nonlinear-system-id"
  },"193": {
    "doc": "System ID",
    "title": "Linear ARX (Auto-Regressive Exogeneous Input)",
    "content": ". An ARX system is a type of discrete-time, linear, time-invariant model used in system identification, where the output is modeled as an Auto-Regressive model with eXogenous input. The system is described by a linear difference equation: . \\[y(t) + a_1 y(t-1) + a_2 y(t-2) + \\dots + a_{n_a} y(t-n_a) = b_1 u(t-1) + b_2 u(t-2) + \\dots + b_{n_b} u(t-n_b) + e(t)\\] Where: . | \\(y(t)\\) ‚Äî output at time \\(t\\) | \\(u(t)\\) ‚Äî input at time \\(t\\) | \\(e(t)\\) ‚Äî white noise (modeling disturbances) | \\(a_i\\) ‚Äî parameters of the autoregressive part (based on past outputs) | \\(b_i\\) ‚Äî parameters of the exogenous part (based on past inputs) | \\(n_a\\) ‚Äî number of past outputs used | \\(n_b\\) ‚Äî number of past inputs used (often includes a delay \\(n_k\\)) | . In compact notation: . [ A(q^{-1})y(t) = B(q^{-1})u(t) + e(t) ] . where \\(q^{-1}\\) is the backward shift operator (\\(q^{-1} y(t) = y(t-1)\\)). Key Points . | AR part: models how past outputs affect the current output. | X (exogenous) part: models how past inputs affect the current output. | Linear in parameters ‚Äî easy to estimate using least squares. | Assumes disturbances \\(e(t)\\) are uncorrelated with the inputs. | . ",
    "url": "/notes/system_id.html#linear-arx-auto-regressive-exogeneous-input",
    
    "relUrl": "/notes/system_id.html#linear-arx-auto-regressive-exogeneous-input"
  },"194": {
    "doc": "System ID",
    "title": "NARX Systems",
    "content": "A NARX system is a Nonlinear Auto-Regressive model with eXogenous input. It extends the ARX model by allowing nonlinear relationships between past inputs, past outputs, and the current output. The general form is: . \\[y(t) = F\\big( y(t-1), y(t-2), \\dots, y(t-n_a), \\; u(t-1), u(t-2), \\dots, u(t-n_b) \\big) + e(t)\\] Where: . | \\(y(t)\\) ‚Äî output at time \\(t\\) | \\(u(t)\\) ‚Äî input at time \\(t\\) | \\(e(t)\\) ‚Äî noise or disturbance | \\(n_a\\) ‚Äî number of past outputs used | \\(n_b\\) ‚Äî number of past inputs used | \\(F(\\cdot)\\) ‚Äî a nonlinear mapping function (e.g., neural network, polynomial, or other nonlinear model) | . Note each of the term may be multiplied by non-linear functions like Fourier-Series. Key Points . | Generalizes ARX by replacing the linear mapping with a nonlinear function. ie \\((y(t-1))^2 + \\sqrt{u(t-1 )}\\) | Captures complex, nonlinear system dynamics more accurately than ARX. | Commonly used in machine learning‚Äìbased system identification. | If \\(F(\\cdot)\\) is linear, the NARX model reduces to the ARX model. | . ",
    "url": "/notes/system_id.html#narx-systems",
    
    "relUrl": "/notes/system_id.html#narx-systems"
  },"195": {
    "doc": "System ID",
    "title": "Stability of NARX",
    "content": "No guarantee of globall stability past captured data. We can approximate the bulk of the system with a linear model which we can analyze the stability of, and capture the remaining residuals with nonlinear terms. ",
    "url": "/notes/system_id.html#stability-of-narx",
    
    "relUrl": "/notes/system_id.html#stability-of-narx"
  },"196": {
    "doc": "System ID",
    "title": "Online and Recursive System ID",
    "content": "The model is developed online over time, using data once it becomes available at each time step. This method is beneficial for time-varying systems. Use Cases of Online System ID . | Adaptive Control . | Time varying systems | . | Fault Detection . | Create fault tests in real time | . | . Finite History Algorithms . Only use part of the most recent past data with a fixed-length window. Online algorithms needs fast execution, so we only use linear models for now. However, we need to store these data. Infinite History (Recursive) Algorithms . Every single data point is run recursively but not stored. Faster execution time. Method 1: Pick a fixed gain K: . Method 2: Since fixed gain is not optimal enough: . Use Kalman!!! . ",
    "url": "/notes/system_id.html#online-and-recursive-system-id",
    
    "relUrl": "/notes/system_id.html#online-and-recursive-system-id"
  },"197": {
    "doc": "System ID",
    "title": "System ID",
    "content": " ",
    "url": "/notes/system_id.html",
    
    "relUrl": "/notes/system_id.html"
  },"198": {
    "doc": "Tips",
    "title": "Stability Tips",
    "content": ". | The Gain and Phase Margins are defined with respect to open-loop transfer function, but the margins are not intrinsic properties of the open-loop system alone, and are only meaningful for the corresponding closed-loop system. | Margins are local properties measured at specific crossover points. It is very possible for a higher-order system to have multiple crossover frequencies and therefore multiple Stability Margins. Conservative Rule the smallest (worst-case) margin dictates stability. | . ",
    "url": "/notes/tips.html#stability-tips",
    
    "relUrl": "/notes/tips.html#stability-tips"
  },"199": {
    "doc": "Tips",
    "title": "Bode, Nyquist, Nichols, Root Locus Tips",
    "content": ". | Nyquist plot is primarily for analysing open-loop system graph to determine closed loop stability - hence the -1 point . | The root locus method, the poles and zeroes you start with are those of the open-loop transfer function. | The root locus then shows how the closed-loop poles move in the s-plane as the gain K varies | The plotted pole/zero markers themselves are always the open-loop ones. | . | When designing a controller, Bode plot you work with is almost always for the open-loop transfer function \\(G(s)H(s)\\) . | . ",
    "url": "/notes/tips.html#bode-nyquist-nichols-root-locus-tips",
    
    "relUrl": "/notes/tips.html#bode-nyquist-nichols-root-locus-tips"
  },"200": {
    "doc": "Tips",
    "title": "Bode plot tips",
    "content": ". | Peaks in Bode plots impact closed-loop stability . | Phase Margin reduction: At the peak, the phase often drops sharply, since the system oscillates more and delays response. If the peak is near the gain crossover frequency, this can push the phase margin down, making the closed-loop system more oscillatory or unstable. | Lower gain margin: If the peak height is close to or above 0 dB, it takes less additional loop gain to cross into instability. | Poor disturbance rejection: Peaks mean the system will amplify disturbances at those frequencies in closed-loop. | High overshoot / ringing: . | . | . ",
    "url": "/notes/tips.html#bode-plot-tips",
    
    "relUrl": "/notes/tips.html#bode-plot-tips"
  },"201": {
    "doc": "Tips",
    "title": "Nyquist Plot tips",
    "content": ". | Nyquist plots are plotted in polar coordinates, in contrast to Bode and Nichols. | Multiplying openloop transfer function by a constant causes Nyquist plot to expand radially outward, pushing the disk margin lower. | If the open loop system is stable (ie. \\(L(s)\\) doesn‚Äôt have any RHP poles), Nyquist plot should not encircle -1 and if it does, it means the closed loop system is unstable. | If the open loop system is unstable (ie. there are RHP poles), Nyquist plot needs to encircle the -1 point \\(N = Z - P\\) times clockwise. This way the closed loop system is stable and the open loop system is called stabilizable. | For a strictly proper or non-strictly proper transfer function, all infinite points not on the imaginary axis on the S-plane are mapped to one single point on the W-plane | For strictly proper systems, that point is the origin. | For nonstrictly proper systems, that point is a non-zero constant with no phase ie the point lies on the positive x-axis. | . ",
    "url": "/notes/tips.html#nyquist-plot-tips",
    
    "relUrl": "/notes/tips.html#nyquist-plot-tips"
  },"202": {
    "doc": "Tips",
    "title": "Root Locus Tips",
    "content": ". | Use lead compansator to drag your asymptotes further to the left, increasing stability and decreases transient response time in time domain. | Asymptotes are important because they‚Äôre the trajectories of closed-loop poles. | . | Never use lag compensator for shaping, only for SSE requirements. Rule of thumb is to place the zero of the lag compensator to be 50 times less than the real part of the dominant pole. | . ",
    "url": "/notes/tips.html#root-locus-tips",
    
    "relUrl": "/notes/tips.html#root-locus-tips"
  },"203": {
    "doc": "Tips",
    "title": "Controllability and Observability Tips",
    "content": ". | Unstable systems are not always uncontrollable. If unstable modes are controllable, then the system is stabilizable. | Degrees of controllability can be determined from the Controllability Gramian or the SVD of the controllability matrix. | Controllability = Reachability. | Degrees of Observability can be determined from the Observability Gramian or the SVD of the observability matrix. | . ",
    "url": "/notes/tips.html#controllability-and-observability-tips",
    
    "relUrl": "/notes/tips.html#controllability-and-observability-tips"
  },"204": {
    "doc": "Tips",
    "title": "Transfer Function and Frequency Analysis tips",
    "content": ". | For an LTI system, the transfer function G(s) is the Laplace transform of the impulse response . | It can be derived either by equations or Testing with impulse response | . | The peaks at resonance on bode plots are caused by the presence of lightly damped poles. A higher order bode plot can have multiple peaks since the system may have multiple lightly damped poles. | The presence of RHP zeroes make the system non-minimum phase by introducing a non-causal phase lag, which means the transient response and step response go in the wrong direction first in time domain. | Each RHP zero cause the system to switch directions. | . | Bode plot shows the steady state response only (evaluating at \\(s=j\\omega\\)). Transient response can only be investigated in time-domain since it is a time baseed phenomenon. | Avoid \\(|L(s)| = 0 dB, \\angle L(s) = -180^\\circ, \\text{ where } |L(s)| \\text{ is the open-loop transfer function}\\). This is the boundary of stability. At this point gain = -1 (magnitude = 1, phase = \\(-180^\\circ\\)), which causes denominator of closed loop transfer function to be 0. | Non-miminum phase can be primarily caused by three phenomena: 1. Time delay \\(e^{-sT}\\) 2. RHP zeroes 3. Non-causal/Inverse-unstable Dynamics (Non-causal systems depend on input in the future). | Only RHP zeroes can cause step response of the system to go in the wrong direction first. Time delay only causes the step response to shift to the right. | . | Easiest way to deal with RHP zeroes is to lower controller gain (shift magnitude plot down, thereby shifting x axis intercept to the left) to maintain stability and increase phase margin. Allocating a pole to cancel out RHP zero at the plant is risky since the output of the controller can be unbounded even if output of the plant (ie entire system) is stable. | Dominant Poles are typically those with the smallest damping since the impulse response of poles with larger real parts quickly disappears. | . ",
    "url": "/notes/tips.html#transfer-function-and-frequency-analysis-tips",
    
    "relUrl": "/notes/tips.html#transfer-function-and-frequency-analysis-tips"
  },"205": {
    "doc": "Tips",
    "title": "Sensitivity and Complementary Sensitivity Tips",
    "content": ". | Sensitivity plots also have peaks at gain crossover frequencies. These peaks occur where the Open Loop Transfer Function \\(L(s)\\) is close to -1 in the complex plane. This often happens near the gain crossover frequency and when there is low damping (phase lag close to \\(-180^\\circ\\)). | Complementary sensitivity plots have bumps at open-loop resonance frequencies. | . | Gain Crossover frequency is defined as the frequency \\(\\omega_{gc}\\) at which \\(|L(j\\omega)|=1\\) . | Time delay and Non-minimum phase place a fundamental limit on how small \\(max(|S|)\\) can be! This is a hard rule that needs to be satisfied. One can shift \\(\\omega_{gc}\\) to the left, which means the system can only track low frequency references and reject lower frequency disturbances. | Peaks in Sensitivity Plots are directly correlated with Gain and Phase Margins. The smaller the margins, the bigger the peak. | Design requirements in time domain can be characterized by features in frequency domain. Since \\(T_r \\omega_b=2\\), where \\(T_r\\) is the rise time and \\(\\omega_b\\) is the bandwidth, increasing rise time is the same as increasing bandwidth. | . | . ",
    "url": "/notes/tips.html#sensitivity-and-complementary-sensitivity-tips",
    
    "relUrl": "/notes/tips.html#sensitivity-and-complementary-sensitivity-tips"
  },"206": {
    "doc": "Tips",
    "title": "Loop shaping Tips",
    "content": ". | Loop shaping is a technique that tries to shape the Open Loop Transfer Function \\(L(s)\\), according to the desired shape - an integrator. The Transfer Function on the bode plot can be shifted left or right by multiplying \\(L(s)\\) with \\(\\omega_{s}\\) to change the gain at low and high frequencies. | One of the key limitations of loop shaping occurs when we have the possibility of cancellation of right half plane poles and zeros. The canceled poles and zeros do not appear in the loop transfer function but they can appear in the transfer functions from disturbances to outputs or control signals. | Non-minimum phase systems impose severe restrictions on possible crossover frequencies according to the crossoverfrequency inequality. | . | . ",
    "url": "/notes/tips.html#loop-shaping-tips",
    
    "relUrl": "/notes/tips.html#loop-shaping-tips"
  },"207": {
    "doc": "Tips",
    "title": "State Space Tips",
    "content": " ",
    "url": "/notes/tips.html#state-space-tips",
    
    "relUrl": "/notes/tips.html#state-space-tips"
  },"208": {
    "doc": "Tips",
    "title": "State Space Matrix Tips",
    "content": ". | In a linear time-invariant system with feedthrough (D*u) term. The poles of the system are only dependent on the eigenvalues of the A matrix, while the zeroes are dependent on all A, B, C, D matrices. | To change the poles, you need to re-design the system (dictated by eigenvalues of A). | To change the zeros, you can change the sensors. | . | Zero appears whenever there is a frequency at which the system‚Äôs input-output path completely cancels out - a nonzero input produces no output in the steady state response. | | . ",
    "url": "/notes/tips.html#state-space-matrix-tips",
    
    "relUrl": "/notes/tips.html#state-space-matrix-tips"
  },"209": {
    "doc": "Tips",
    "title": "LQG and Extended Kalman Tips",
    "content": ". | An LQG controller does not have any guarantee on robustness. | LQR and LQR solves an Algebraic Riccati Equation to calculate an analytical solution to the problem given Q and R. | If the system is observable, LQE can deduce all states from a few measurable states. Degrees of observability would be helpful when desining an observer. | . ",
    "url": "/notes/tips.html#lqg-and-extended-kalman-tips",
    
    "relUrl": "/notes/tips.html#lqg-and-extended-kalman-tips"
  },"210": {
    "doc": "Tips",
    "title": "Tips",
    "content": " ",
    "url": "/notes/tips.html",
    
    "relUrl": "/notes/tips.html"
  },"211": {
    "doc": "Control Tools",
    "title": "Control Using Simulink &amp; Python",
    "content": "Coming soon‚Ä¶ . ",
    "url": "/notes/tools.html#control-using-simulink--python",
    
    "relUrl": "/notes/tools.html#control-using-simulink--python"
  },"212": {
    "doc": "Control Tools",
    "title": "Control Tools",
    "content": " ",
    "url": "/notes/tools.html",
    
    "relUrl": "/notes/tools.html"
  },"213": {
    "doc": "Control System Design Workflow",
    "title": "Control System Specs ‚Üí Design Actions Cheat Sheet",
    "content": "| Requirement / Spec | What It Means | Design Adjustments | . | Steady-State Error (Ess) | Final tracking error to step/ramp inputs | Increase system type (add integrator), adjust Ki in PID, or use lag compensator | . | Rise Time (tr) | Speed to reach near-final value | Increase system bandwidth, add lead compensator, increase Kp | . | Overshoot (Mp) | How much output exceeds target | Increase damping ratio (reduce Kp, increase Kd), use lead-lag tuning | . | Settling Time (ts) | Time to stay within ¬±X% band | Increase natural frequency, increase damping via derivative gain or lead compensation | . | Damping Ratio (Œ∂) | Oscillation level in transient | Adjust Kd or use lead to increase phase margin | . | Gain Margin (GM) | How much gain can increase before instability | Add phase lead, reduce open-loop gain | . | Phase Margin (PM) | Extra phase lag before instability | Add phase lead, adjust crossover frequency | . | Bandwidth | Frequency range of good tracking | Increase gain/lead for faster response, but watch noise | . | Disturbance Rejection | Suppress low/high frequency disturbances | Add integrator for low-freq rejection, notch filters for specific frequencies | . | Noise Sensitivity | Avoid amplifying sensor noise | Reduce bandwidth, use low-pass filter on derivative term | . | Control Effort Limit | Actuator magnitude/rate constraints | Add rate limiter, reduce aggressive gains, use anti-windup | . ",
    "url": "/notes/workflow.html#control-system-specs--design-actions-cheat-sheet",
    
    "relUrl": "/notes/workflow.html#control-system-specs--design-actions-cheat-sheet"
  },"214": {
    "doc": "Control System Design Workflow",
    "title": "Quick Tuning Tips",
    "content": ". | Too slow? ‚Üí Increase Kp, add lead, raise bandwidth. | Too oscillatory? ‚Üí Increase damping (Kd), reduce Kp, add lag. | Steady-state error too high? ‚Üí Add integrator (Ki) or lag compensation. | Noisy response? ‚Üí Lower bandwidth, filter derivative term. | . ",
    "url": "/notes/workflow.html#quick-tuning-tips",
    
    "relUrl": "/notes/workflow.html#quick-tuning-tips"
  },"215": {
    "doc": "Control System Design Workflow",
    "title": "Quick Tuning Tips",
    "content": ". | Too slow? ‚Üí Increase Kp, add lead, raise bandwidth. | Too oscillatory? ‚Üí Increase damping (Kd), reduce Kp, add lag. | Steady-state error too high? ‚Üí Add integrator (Ki) or lag compensation. | Noisy response? ‚Üí Lower bandwidth, filter derivative term. | . ",
    "url": "/notes/workflow.html#quick-tuning-tips-1",
    
    "relUrl": "/notes/workflow.html#quick-tuning-tips-1"
  },"216": {
    "doc": "Control System Design Workflow",
    "title": "Control System Design Workflow",
    "content": " ",
    "url": "/notes/workflow.html",
    
    "relUrl": "/notes/workflow.html"
  }
}
